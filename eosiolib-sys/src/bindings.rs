/* automatically generated by rust-bindgen */

pub const _LIBCPP_VERSION: u32 = 5000;
pub const _LIBCPP_ABI_VERSION: u32 = 1;
pub const _LIBCPP_OBJECT_FORMAT_ELF: u32 = 1;
pub const _LIBCPP_LITTLE_ENDIAN: u32 = 1;
pub const _LIBCPP_BIG_ENDIAN: u32 = 0;
pub const _LIBCPP_LOCALE__L_EXTENSIONS: u32 = 1;
pub const _LIBCPP_HAS_CATOPEN: u32 = 1;
pub const _LIBCPP_STD_VER: u32 = 14;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST64_MAX: i32 = -1;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INTMAX_MIN: i64 = -9223372036854775808;
pub const INTMAX_MAX: u64 = 9223372036854775807;
pub const UINTMAX_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const NULL: u32 = 0;
pub const WEOF: u32 = 4294967295;
pub type uint128_t = [u64; 2];
pub type int128_t = [u64; 2];
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
pub type wint_t = u32;
pub type va_list = __builtin_va_list;
pub type __isoc_va_list = __builtin_va_list;
pub type wctype_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __mbstate_t {
    pub __opaque1: ::std::os::raw::c_uint,
    pub __opaque2: ::std::os::raw::c_uint,
}
pub type mbstate_t = __mbstate_t;
pub type regoff_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    _unused: [u8; 0],
}
pub type locale_t = *mut __locale_struct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    _unused: [u8; 0],
}
pub type FILE = _IO_FILE;
pub type off_t = i64;
pub type time_t = ::std::os::raw::c_long;
pub type suseconds_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: time_t,
    pub tv_usec: suseconds_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
pub type float_t = f32;
pub type double_t = f64;
extern "C" {
    pub fn wcscpy(arg1: *mut u32, arg2: *const u32) -> *mut u32;
}
extern "C" {
    pub fn wcsncpy(arg1: *mut u32, arg2: *const u32, arg3: usize) -> *mut u32;
}
extern "C" {
    pub fn wcscat(arg1: *mut u32, arg2: *const u32) -> *mut u32;
}
extern "C" {
    pub fn wcsncat(arg1: *mut u32, arg2: *const u32, arg3: usize) -> *mut u32;
}
extern "C" {
    pub fn wcscmp(arg1: *const u32, arg2: *const u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsncmp(arg1: *const u32, arg2: *const u32, arg3: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcscoll(arg1: *const u32, arg2: *const u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsxfrm(arg1: *mut u32, arg2: *const u32, arg3: usize) -> usize;
}
extern "C" {
    pub fn wcschr(arg1: *const u32, arg2: u32) -> *mut u32;
}
extern "C" {
    pub fn wcsrchr(arg1: *const u32, arg2: u32) -> *mut u32;
}
extern "C" {
    pub fn wcscspn(arg1: *const u32, arg2: *const u32) -> usize;
}
extern "C" {
    pub fn wcsspn(arg1: *const u32, arg2: *const u32) -> usize;
}
extern "C" {
    pub fn wcspbrk(arg1: *const u32, arg2: *const u32) -> *mut u32;
}
extern "C" {
    pub fn wcstok(arg1: *mut u32, arg2: *const u32, arg3: *mut *mut u32) -> *mut u32;
}
extern "C" {
    pub fn wcslen(arg1: *const u32) -> usize;
}
extern "C" {
    pub fn wcsstr(arg1: *const u32, arg2: *const u32) -> *mut u32;
}
extern "C" {
    pub fn wcswcs(arg1: *const u32, arg2: *const u32) -> *mut u32;
}
extern "C" {
    pub fn wmemchr(arg1: *const u32, arg2: u32, arg3: usize) -> *mut u32;
}
extern "C" {
    pub fn wmemcmp(arg1: *const u32, arg2: *const u32, arg3: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wmemcpy(arg1: *mut u32, arg2: *const u32, arg3: usize) -> *mut u32;
}
extern "C" {
    pub fn wmemmove(arg1: *mut u32, arg2: *const u32, arg3: usize) -> *mut u32;
}
extern "C" {
    pub fn wmemset(arg1: *mut u32, arg2: u32, arg3: usize) -> *mut u32;
}
extern "C" {
    pub fn btowc(arg1: ::std::os::raw::c_int) -> wint_t;
}
extern "C" {
    pub fn wctob(arg1: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbsinit(arg1: *const mbstate_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbrtowc(
        arg1: *mut u32,
        arg2: *const ::std::os::raw::c_char,
        arg3: usize,
        arg4: *mut mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn wcrtomb(arg1: *mut ::std::os::raw::c_char, arg2: u32, arg3: *mut mbstate_t) -> usize;
}
extern "C" {
    pub fn mbrlen(arg1: *const ::std::os::raw::c_char, arg2: usize, arg3: *mut mbstate_t) -> usize;
}
extern "C" {
    pub fn mbsrtowcs(
        arg1: *mut u32,
        arg2: *mut *const ::std::os::raw::c_char,
        arg3: usize,
        arg4: *mut mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn wcsrtombs(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *mut *const u32,
        arg3: usize,
        arg4: *mut mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn wcstof(arg1: *const u32, arg2: *mut *mut u32) -> f32;
}
extern "C" {
    pub fn wcstod(arg1: *const u32, arg2: *mut *mut u32) -> f64;
}
extern "C" {
    pub fn wcstold(arg1: *const u32, arg2: *mut *mut u32) -> f64;
}
extern "C" {
    pub fn wcstol(
        arg1: *const u32,
        arg2: *mut *mut u32,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn wcstoul(
        arg1: *const u32,
        arg2: *mut *mut u32,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn wcstoll(
        arg1: *const u32,
        arg2: *mut *mut u32,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn wcstoull(
        arg1: *const u32,
        arg2: *mut *mut u32,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn fwide(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wprintf(arg1: *const u32, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fwprintf(arg1: *mut FILE, arg2: *const u32, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn swprintf(arg1: *mut u32, arg2: usize, arg3: *const u32, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vwprintf(arg1: *const u32, arg2: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfwprintf(
        arg1: *mut FILE,
        arg2: *const u32,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vswprintf(
        arg1: *mut u32,
        arg2: usize,
        arg3: *const u32,
        arg4: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wscanf(arg1: *const u32, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fwscanf(arg1: *mut FILE, arg2: *const u32, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn swscanf(arg1: *const u32, arg2: *const u32, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vwscanf(arg1: *const u32, arg2: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfwscanf(
        arg1: *mut FILE,
        arg2: *const u32,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vswscanf(
        arg1: *const u32,
        arg2: *const u32,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetwc(arg1: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn getwc(arg1: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn getwchar() -> wint_t;
}
extern "C" {
    pub fn fputwc(arg1: u32, arg2: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn putwc(arg1: u32, arg2: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn putwchar(arg1: u32) -> wint_t;
}
extern "C" {
    pub fn fgetws(arg1: *mut u32, arg2: ::std::os::raw::c_int, arg3: *mut FILE) -> *mut u32;
}
extern "C" {
    pub fn fputws(arg1: *const u32, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetwc(arg1: wint_t, arg2: *mut FILE) -> wint_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    _unused: [u8; 0],
}
extern "C" {
    pub fn wcsftime(arg1: *mut u32, arg2: usize, arg3: *const u32, arg4: *const tm) -> usize;
}
/// @brief Name of an account
/// @details Name of an account
pub type account_name = u64;
/// @brief Name of a permission
/// @details Name of an account
pub type permission_name = u64;
/// @brief Name of a table
/// @details Name of atable
pub type table_name = u64;
/// @brief Time
/// @details Time
pub type time = u32;
/// @brief Name of a scope
/// @details Name of a scope
pub type scope_name = u64;
/// @brief Name of an action
/// @details Name of an action
pub type action_name = u64;
/// @brief Macro to align/overalign a type to ensure calls to intrinsics with pointers/references are properly aligned
/// @details Macro to align/overalign a type to ensure calls to intrinsics with pointers/references are properly aligned
pub type weight_type = u16;
/// @brief EOSIO Public Key
/// @details EOSIO Public Key. It is 34 bytes.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct public_key {
    pub data: [::std::os::raw::c_char; 34usize],
}
/// @brief EOSIO Signature
/// @details EOSIO Signature. It is 66 bytes.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct signature {
    pub data: [u8; 66usize],
}
/// @brief 256-bit hash
/// @details 256-bit hash
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct checksum256 {
    pub hash: [u8; 32usize],
}
/// @brief 160-bit hash
/// @details 160-bit hash
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct checksum160 {
    pub hash: [u8; 20usize],
    pub __bindgen_padding_0: [u32; 3usize],
}
/// @brief 512-bit hash
/// @details 512-bit hash
#[repr(C)]
#[derive(Copy, Clone)]
pub struct checksum512 {
    pub hash: [u8; 64usize],
}
/// @brief Type of EOSIO Transaction Id
/// @details Type of EOSIO Transaction Id. It is 256-bit hash
pub type transaction_id_type = checksum256;
pub type block_id_type = checksum256;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct account_permission {
    pub account: account_name,
    pub permission: permission_name,
}
extern "C" {
    /// Aborts processing of this action and unwinds all pending changes if the test condition is true
    /// @brief Aborts processing of this action and unwinds all pending changes
    /// @param test - 0 to abort, 1 to ignore
    ///
    /// Example:
    ///
    /// @code
    /// eosio_assert(1 == 2, "One is not equal to two.");
    /// eosio_assert(1 == 1, "One is not equal to one.");
    /// @endcode
    ///
    /// @param msg - a null terminated string explaining the reason for failure
    pub fn eosio_assert(test: u32, msg: *const ::std::os::raw::c_char);
}
extern "C" {
    /// Aborts processing of this action and unwinds all pending changes if the test condition is true
    /// @brief Aborts processing of this action and unwinds all pending changes
    /// @param test - 0 to abort, 1 to ignore
    /// @param msg - a pointer to the start of string explaining the reason for failure
    /// @param msg_len - length of the string
    pub fn eosio_assert_message(test: u32, msg: *const ::std::os::raw::c_char, msg_len: u32);
}
extern "C" {
    /// Aborts processing of this action and unwinds all pending changes if the test condition is true
    /// @brief Aborts processing of this action and unwinds all pending changes
    /// @param test - 0 to abort, 1 to ignore
    /// @param code - the error code
    pub fn eosio_assert_code(test: u32, code: u64);
}
extern "C" {
    /// This method will abort execution of wasm without failing the contract. This is used to bypass all cleanup / destructors that would normally be called.
    /// @brief Aborts execution of wasm without failing the contract
    /// @param code - the exit code
    /// Example:
    ///
    /// @code
    /// eosio_exit(0);
    /// eosio_exit(1);
    /// eosio_exit(2);
    /// eosio_exit(3);
    /// @endcode
    pub fn eosio_exit(code: i32);
}
extern "C" {
    /// Returns the time in microseconds from 1970 of the current block
    /// @brief Get time of the current block (i.e. the block including this action)
    /// @return time in microseconds from 1970 of the current block
    pub fn current_time() -> u64;
}
extern "C" {
    /// Copy up to @ref len bytes of current action data to the specified location
    ///
    /// @brief Copy current action data to the specified location
    /// @param msg - a pointer where up to @ref len bytes of the current action data will be copied
    /// @param len - len of the current action data to be copied, 0 to report required size
    /// @return the number of bytes copied to msg, or number of bytes that can be copied if len==0 passed
    /// @pre `msg` is a valid pointer to a range of memory at least `len` bytes long
    /// @post `msg` is filled with packed action data
    pub fn read_action_data(msg: *mut ::std::os::raw::c_void, len: u32) -> u32;
}
extern "C" {
    /// Get the length of the current action's data field. This method is useful for dynamically sized actions
    ///
    /// @brief Get the length of current action's data field
    /// @return the length of the current action's data field
    pub fn action_data_size() -> u32;
}
extern "C" {
    /// Add the specified account to set of accounts to be notified
    ///
    /// @brief Add the specified account to set of accounts to be notified
    /// @param name - name of the account to be verified
    pub fn require_recipient(name: account_name);
}
extern "C" {
    /// Verifies that @ref name exists in the set of provided auths on a action. Throws if not found.
    ///
    /// @brief Verify specified account exists in the set of provided auths
    /// @param name - name of the account to be verified
    pub fn require_auth(name: account_name);
}
extern "C" {
    /// Verifies that @ref name has auth.
    ///
    /// @brief Verifies that @ref name has auth.
    /// @param name - name of the account to be verified
    pub fn has_auth(name: account_name) -> bool;
}
extern "C" {
    /// Verifies that @ref name exists in the set of provided auths on a action. Throws if not found.
    ///
    /// @brief Verify specified account exists in the set of provided auths
    /// @param name - name of the account to be verified
    /// @param permission - permission level to be verified
    pub fn require_auth2(name: account_name, permission: permission_name);
}
extern "C" {
    pub fn is_account(name: account_name) -> bool;
}
extern "C" {
    /// Send an inline action in the context of this action's parent transaction
    ///
    /// @param serialized_action - serialized action
    /// @param size - size of serialized action in bytes
    /// @pre `serialized_action` is a valid pointer to an array at least `size` bytes long
    pub fn send_inline(serialized_action: *mut ::std::os::raw::c_char, size: usize);
}
extern "C" {
    /// Send an inline context free action in the context of this action's parent transaction
    ///
    /// @param serialized_action - serialized action
    /// @param size - size of serialized action in bytes
    /// @pre `serialized_action` is a valid pointer to an array at least `size` bytes long
    pub fn send_context_free_inline(serialized_action: *mut ::std::os::raw::c_char, size: usize);
}
extern "C" {
    /// Verifies that @ref name exists in the set of write locks held on a action. Throws if not found
    /// @brief Verifies that @ref name exists in the set of write locks held
    /// @param name - name of the account to be verified
    pub fn require_write_lock(name: account_name);
}
extern "C" {
    /// Verifies that @ref name exists in the set of read locks held on a action. Throws if not found
    /// @brief Verifies that @ref name exists in the set of read locks held
    /// @param name - name of the account to be verified
    pub fn require_read_lock(name: account_name);
}
extern "C" {
    /// Returns the time in microseconds from 1970 of the publication_time
    /// @brief Get the publication time
    /// @return the time in microseconds from 1970 of the publication_time
    pub fn publication_time() -> u64;
}
extern "C" {
    /// Get the current receiver of the action
    /// @brief Get the current receiver of the action
    /// @return the account which specifies the current receiver of the action
    pub fn current_receiver() -> account_name;
}
extern "C" {
    /// Gets the set of active producers.
    /// @brief Gets the set of active producers.
    ///
    /// @param producers - Pointer to a buffer of account names
    /// @param datalen - Byte length of buffer, when passed 0 will return the size required to store full output.
    ///
    /// @return uint32_t - Number of bytes actually populated
    /// @pre `producers` is a pointer to a range of memory at least `datalen` bytes long
    /// @post the passed in `producers` pointer gets the array of active producers.
    ///
    /// Example:
    ///
    /// @code
    /// account_name producers[21];
    /// uint32_t bytes_populated = get_active_producers(producers, sizeof(account_name)*21);
    /// @endcode
    pub fn get_active_producers(producers: *mut account_name, datalen: u32) -> u32;
}
extern "C" {
    /// Multiply two 128 bit integers split as two 64 bit unsigned integers and assign the value to the first parameter.
    /// @brief Multiply two 128 unsigned bit integers (which are represented as two 64 bit unsigned integers.
    /// @param res  It will be replaced with the result product.
    /// @param la   Low 64 bits of the first 128 bit factor.
    /// @param ha   High 64 bits of the first 128 bit factor.
    /// @param lb   Low 64 bits of the second 128 bit factor.
    /// @param hb   High 64 bits of the second 128 bit factor.
    /// @post `res` is replaced with the result of multiplication
    /// Example:
    /// @code
    /// __int128 res = 0;
    /// __int128 a = 100;
    /// __int128 b = 100;
    /// __multi3(res, a, (a >> 64), b, (b >> 64));
    /// printi128(&res); // Output: 10000
    /// @endcode
    pub fn __multi3(res: *mut [u64; 2], la: u64, ha: u64, lb: u64, hb: u64);
}
extern "C" {
    /// Divide two 128 bit integers split as two 64 bit unsigned integers and assign the value to the first parameter.
    /// @brief Divide two 128 bit integers (which are represented as two 64 bit unsigned integers)
    /// @param res  It will be replaced with the result product.
    /// @param la   Low 64 bits of the first 128 bit factor.
    /// @param ha   High 64 bits of the first 128 bit factor.
    /// @param lb   Low 64 bits of the second 128 bit factor.
    /// @param hb   High 64 bits of the second 128 bit factor.
    /// @post `res` is replaced with the result of division
    /// Example:
    /// @code
    /// __int128 res = 0;
    /// __int128 a = 100;
    /// __int128 b = 100;
    /// __divti3(res, a, (a >> 64), b, (b >> 64));
    /// printi128(&res); // Output: 1
    /// @endcode
    pub fn __divti3(res: *mut [u64; 2], la: u64, ha: u64, lb: u64, hb: u64);
}
extern "C" {
    /// Divide two 128 bit unsigned integers split as two 64 bit unsigned integers and assign the value to the first parameter.
    /// @brief Divide two 128 unsigned bit integers (which are represented as two 64 bit unsigned integers)
    /// @param res  It will be replaced with the result product.
    /// @param la   Low 64 bits of the first 128 bit factor.
    /// @param ha   High 64 bits of the first 128 bit factor.
    /// @param lb   Low 64 bits of the second 128 bit factor.
    /// @param hb   High 64 bits of the second 128 bit factor.
    /// Example:
    /// @code
    /// unsigned __int128 res = 0;
    /// unsigned __int128 a = 100;
    /// unsigned __int128 b = 100;
    /// __udivti3(res, a, (a >> 64), b, (b >> 64));
    /// printi128(&res); // Output: 1
    /// @endcode
    pub fn __udivti3(res: *mut [u64; 2], la: u64, ha: u64, lb: u64, hb: u64);
}
extern "C" {
    /// Perform modular arithmetic on two 128 bit integers split as two 64 bit unsigned integers and assign the value to the first parameter.
    /// @brief Perform modular arithmetic on two 128 bit integers (which are represented as two 64 bit unsigned integers)
    /// @param res  It will be replaced with the result product.
    /// @param la   Low 64 bits of the first 128 bit factor.
    /// @param ha   High 64 bits of the first 128 bit factor.
    /// @param lb   Low 64 bits of the second 128 bit factor.
    /// @param hb   High 64 bits of the second 128 bit factor.
    /// @post `res` is replaced with the result of modulus
    /// Example:
    /// @code
    /// __int128 res = 0;
    /// __int128 a = 100;
    /// __int128 b = 3;
    /// __modti3(res, a, (a >> 64), b, (b >> 64));
    /// printi128(&res); // Output: 1
    /// @endcode
    pub fn __modti3(res: *mut [u64; 2], la: u64, ha: u64, lb: u64, hb: u64);
}
extern "C" {
    /// Perform modular arithmetic on two 128 unsigned bit integers split as two 64 bit unsigned integers and assign the value to the first parameter.
    /// @brief Perform modular arithmetic on two 128 unsigned bit integers (which are represented as two 64 bit unsigned integers)
    /// @param res  It will be replaced with the result product.
    /// @param la   Low 64 bits of the first 128 bit factor.
    /// @param ha   High 64 bits of the first 128 bit factor.
    /// @param lb   Low 64 bits of the second 128 bit factor.
    /// @param hb   High 64 bits of the second 128 bit factor.
    /// @post `res` is replaced with the result of modulus
    /// Example:
    /// @code
    /// unsigned __int128 res = 0;
    /// unsigned __int128 a = 100;
    /// unsigned __int128 b = 3;
    /// __umodti3(res, a, (a >> 64), b, (b >> 64));
    /// printi128(&res); // Output: 1
    /// @endcode
    pub fn __umodti3(res: *mut [u64; 2], la: u64, ha: u64, lb: u64, hb: u64);
}
extern "C" {
    /// Perform logical shift left on a 128 bit integer split as two 64 bit unsigned integers and assign the value to the first parameter.
    /// @brief Perform logical shift left on a 128 bit integer (which is represented as two 64 bit unsigned integers)
    /// @param res    It will be replaced with the result product.
    /// @param lo     Low 64 bits of the 128 bit factor.
    /// @param hi     High 64 bits of the 128 bit factor.
    /// @param shift  Number of bits to shift.
    /// @post `res` is replaced with the result of the operation
    /// Example:
    /// @code
    /// __int128 res = 0;
    /// __int128 a = 8;
    /// __lshlti3(res, a, (a >> 64), 1);
    /// printi128(&res); // Output: 16
    /// @endcode
    pub fn __lshlti3(res: *mut [u64; 2], lo: u64, hi: u64, shift: u32);
}
extern "C" {
    /// Perform logical shift right on a 128 bit integer split as two 64 bit unsigned integers and assign the value to the first parameter.
    /// @brief Perform logical shift right on a 128 bit integer (which is represented as two 64 bit unsigned integers)
    /// @param res    It will be replaced with the result product.
    /// @param lo     Low 64 bits of the 128 bit factor.
    /// @param hi     High 64 bits of the 128 bit factor.
    /// @param shift  Number of bits to shift.
    /// @post `res` is replaced with the result of the operation
    /// Example:
    /// @code
    /// __int128 res = 0;
    /// __int128 a = 8;
    /// __lshrti3(res, a, (a >> 64), 1);
    /// printi128(&res); // Output: 4
    /// @endcode
    pub fn __lshrti3(res: *mut [u64; 2], lo: u64, hi: u64, shift: u32);
}
extern "C" {
    /// Perform arithmetic shift left on a 128 bit integer split as two 64 bit unsigned integers and assign the value to the first parameter.
    /// @brief Perform arithmetic shift left on a 128 bit integer (which is represented as two 64 bit unsigned integers)
    /// @param res    It will be replaced with the result product.
    /// @param lo     Low 64 bits of the 128 bit factor.
    /// @param hi     High 64 bits of the 128 bit factor.
    /// @param shift  Number of bits to shift.
    /// @post `res` is replaced with the result of the operation
    /// Example:
    /// @code
    /// __int128 res = 0;
    /// __int128 a = 8;
    /// __ashlti3(res, a, (a >> 64), 1);
    /// printi128(&res); // Output: 16
    /// @endcode
    pub fn __ashlti3(res: *mut [u64; 2], lo: u64, hi: u64, shift: u32);
}
extern "C" {
    /// Perform arithmetic shift right on a 128 bit integer split as two 64 bit unsigned integers and assign the value to the first parameter.
    /// @brief Perform arithmetic shift right on a 128 bit integer (which is represented as two 64 bit unsigned integers)
    /// @param res    It will be replaced with the result product.
    /// @param lo     Low 64 bits of the 128 bit factor.
    /// @param hi     High 64 bits of the 128 bit factor.
    /// @param shift  Number of bits to shift.
    /// @post `res` is replaced with the result of the operation
    /// Example:
    /// @code
    /// __int128 res = 0;
    /// __int128 a = -8;
    /// __ashrti3(res, a, (a >> 64), 1);
    /// printi128(&res); // Output: -4
    /// @endcode
    pub fn __ashrti3(res: *mut [u64; 2], lo: u64, hi: u64, shift: u32);
}
extern "C" {
    /// Add two long doubles split as two 64 bit unsigned integers and assign the value to the first parameter.
    /// @brief Add two long doubles (which are represented as two 64 bit unsigned integers)
    /// @param res  It will be replaced with the result product.
    /// @param la   Low 64 bits of the first 128 bit factor.
    /// @param ha   High 64 bits of the first 128 bit factor.
    /// @param lb   Low 64 bits of the second 128 bit factor.
    /// @param hb   High 64 bits of the second 128 bit factor.
    /// @post `ret` is replaced with the result of the operation
    pub fn __addtf3(ret: *mut f64, la: u64, ha: u64, lb: u64, hb: u64);
}
extern "C" {
    /// Subtract two long doubles split as two 64 bit unsigned integers and assign the value to the first parameter.
    /// @brief Subtract two long doubles (which are represented as two 64 bit unsigned integers)
    /// @param res  It will be replaced with the result product.
    /// @param la   Low 64 bits of the first 128 bit factor.
    /// @param ha   High 64 bits of the first 128 bit factor.
    /// @param lb   Low 64 bits of the second 128 bit factor.
    /// @param hb   High 64 bits of the second 128 bit factor.
    /// @post `ret` is replaced with the result of the operation
    pub fn __subtf3(ret: *mut f64, la: u64, ha: u64, lb: u64, hb: u64);
}
extern "C" {
    /// Multiply two long doubles split as two 64 bit unsigned integers and assign the value to the first parameter.
    /// @brief Multiply two long doubles (which are represented as two 64 bit unsigned integers)
    /// @param res  It will be replaced with the result product.
    /// @param la   Low 64 bits of the first 128 bit factor.
    /// @param ha   High 64 bits of the first 128 bit factor.
    /// @param lb   Low 64 bits of the second 128 bit factor.
    /// @param hb   High 64 bits of the second 128 bit factor.
    /// @post `ret` is replaced with the result of the operation
    pub fn __multf3(ret: *mut f64, la: u64, ha: u64, lb: u64, hb: u64);
}
extern "C" {
    /// Divide two long doubles split as two 64 bit unsigned integers and assign the value to the first parameter.
    /// @brief Divide two long doubles (which are represented as two 64 bit unsigned integers)
    /// @param res  It will be replaced with the result product.
    /// @param la   Low 64 bits of the first 128 bit factor.
    /// @param ha   High 64 bits of the first 128 bit factor.
    /// @param lb   Low 64 bits of the second 128 bit factor.
    /// @param hb   High 64 bits of the second 128 bit factor.
    /// @post `ret` is replaced with the result of the operation
    pub fn __divtf3(ret: *mut f64, la: u64, ha: u64, lb: u64, hb: u64);
}
extern "C" {
    /// Check equality between two doubles split as two 64 bit unsigned integers
    /// @brief Check equality between two doubles (which are represented as two 64 bit unsigned integers)
    /// @param res  It will be replaced with the result product.
    /// @param la   Low 64 bits of the first 128 bit factor.
    /// @param ha   High 64 bits of the first 128 bit factor.
    /// @param lb   Low 64 bits of the second 128 bit factor.
    /// @param hb   High 64 bits of the second 128 bit factor.
    /// @return 1 if a greater than b
    /// @return 0 if a equal to b
    /// @return -1 if a less than b
    /// @return 1 if either a or b is NaN
    pub fn __eqtf2(la: u64, ha: u64, lb: u64, hb: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Check inequality between two doubles split as two 64 bit unsigned integers
    /// @brief Check inequality between two doubles (which are represented as two 64 bit unsigned integers)
    /// @param res  It will be replaced with the result product.
    /// @param la   Low 64 bits of the first 128 bit factor.
    /// @param ha   High 64 bits of the first 128 bit factor.
    /// @param lb   Low 64 bits of the second 128 bit factor.
    /// @param hb   High 64 bits of the second 128 bit factor.
    /// @return 1 if a greater than b
    /// @return 0 if a equal to b
    /// @return -1 if a less than b
    /// @return1 if either a or b is NaN
    pub fn __netf2(la: u64, ha: u64, lb: u64, hb: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Check if the first double is greater or equal to the second double, the doubles are split as two 64 bit unsigned integers
    /// @brief Check if the first double is greater or equal to the second double, (the doubles are represented as two 64 bit unsigned integers)
    /// @param res  It will be replaced with the result product.
    /// @param la   Low 64 bits of the first 128 bit factor.
    /// @param ha   High 64 bits of the first 128 bit factor.
    /// @param lb   Low 64 bits of the second 128 bit factor.
    /// @param hb   High 64 bits of the second 128 bit factor.
    /// @return 1 if a greater than b
    /// @return 0 if a equal to b
    /// @return -1 if a less than b
    /// @return -1 if either a or b is NaN
    pub fn __getf2(la: u64, ha: u64, lb: u64, hb: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Check if the first double is greater than the second double, the doubles are split as two 64 bit unsigned integers
    /// @brief Check if the first double is greater than the second double, (the doubles are represented as two 64 bit unsigned integers)
    /// @param res  It will be replaced with the result product.
    /// @param la   Low 64 bits of the first 128 bit factor.
    /// @param ha   High 64 bits of the first 128 bit factor.
    /// @param lb   Low 64 bits of the second 128 bit factor.
    /// @param hb   High 64 bits of the second 128 bit factor.
    /// @return 1 if a greater than b
    /// @return 0 if a equal to b
    /// @return -1 if a less than b
    /// @return 0 if either a or b is NaN
    pub fn __gttf2(la: u64, ha: u64, lb: u64, hb: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Check if the first double is less or equal to the second double, the doubles are split as two 64 bit unsigned integers
    /// @brief Check if the first double is less or equal to the second double, (the doubles are represented as two 64 bit unsigned integers)
    /// @param res  It will be replaced with the result product.
    /// @param la   Low 64 bits of the first 128 bit factor.
    /// @param ha   High 64 bits of the first 128 bit factor.
    /// @param lb   Low 64 bits of the second 128 bit factor.
    /// @param hb   High 64 bits of the second 128 bit factor.
    /// @return 1 if a greater than b
    /// @return 0 if a equal to b
    /// @return -1 if a less than b
    /// @return 1 if either a or b is NaN
    pub fn __letf2(la: u64, ha: u64, lb: u64, hb: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Check if the first double is less than the second double, the doubles are split as two 64 bit unsigned integers
    /// @brief Check if the first double is less than the second double, (the doubles are represented as two 64 bit unsigned integers)
    /// @param res  It will be replaced with the result product.
    /// @param la   Low 64 bits of the first 128 bit factor.
    /// @param ha   High 64 bits of the first 128 bit factor.
    /// @param lb   Low 64 bits of the second 128 bit factor.
    /// @param hb   High 64 bits of the second 128 bit factor.
    /// @return 1 if a greater than b
    /// @return 0 if a equal to b
    /// @return -1 if a less than b
    /// @return 0 if either a or b is NaN
    pub fn __lttf2(la: u64, ha: u64, lb: u64, hb: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Compare two doubles which are split as two 64 bit unsigned integers
    /// @brief Compare two doubles (the doubles are represented as two 64 bit unsigned integers)
    /// @param res  It will be replaced with the result product.
    /// @param la   Low 64 bits of the first 128 bit factor.
    /// @param ha   High 64 bits of the first 128 bit factor.
    /// @param lb   Low 64 bits of the second 128 bit factor.
    /// @param hb   High 64 bits of the second 128 bit factor.
    /// @return 1 if a greater than b
    /// @return 0 if a equal to b
    /// @return -1 if a less than b
    /// @return 1 if either a or b is NaN
    pub fn __cmptf2(la: u64, ha: u64, lb: u64, hb: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Check if either of the doubles is NaN, the doubles are split as two 64 bit unsigned integers
    /// @brief Check if either of the doubles is NaN, (the doubles are represented as two 64 bit unsigned integers)
    /// @param res  It will be replaced with the result product.
    /// @param la   Low 64 bits of the first 128 bit factor.
    /// @param ha   High 64 bits of the first 128 bit factor.
    /// @param lb   Low 64 bits of the second 128 bit factor.
    /// @param hb   High 64 bits of the second 128 bit factor.
    /// @return 1 if either a or b is NaN
    /// @return 0 if either a or b is not NaN
    pub fn __unordtf2(la: u64, ha: u64, lb: u64, hb: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Extend float to long double
    /// @brief Extend float to long double
    /// @param ret  It will be replaced with the result product.
    /// @param f    Input float to be extended
    /// @post `ret` is replaced with the extended float
    pub fn __extendsftf2(ret: *mut f64, f: f32);
}
extern "C" {
    /// Extend double to long double
    /// @brief Extend float to long double
    /// @param ret  It will be replaced with the result product.
    /// @param f    Input float to be extended
    /// @post `ret` is replaced with the extended float
    pub fn __extenddftf2(ret: *mut f64, f: f64);
}
extern "C" {
    /// Convert long double (which are split as two 64 bit unsigned integers) into 64 bit integer
    /// @brief Convert long double (which are split as two 64 bit unsigned integers) into 64 bit integer
    /// @param l   Low 64 bits of the first 128 bit factor.
    /// @param h   High 64 bits of the first 128 bit factor.
    /// @return the converted 64 bit integer.
    pub fn __fixtfdi(l: u64, h: u64) -> i64;
}
extern "C" {
    /// Convert long double (which are split as two 64 bit unsigned integers) into 32 bit integer
    /// @brief Convert long double (which are split as two 64 bit unsigned integers) into 32 bit integer
    /// @param l   Low 64 bits of the first 128 bit factor.
    /// @param h   High 64 bits of the first 128 bit factor.
    /// @return the converted 32 bit integer.
    pub fn __fixtfsi(l: u64, h: u64) -> i32;
}
extern "C" {
    /// Convert long double (which are split as two 64 bit unsigned integers) into 64 bit unsigned integer
    /// @brief Convert long double (which are split as two 64 bit unsigned integers) into 64 bit unsigned integer
    /// @param l   Low 64 bits of the first 128 bit factor.
    /// @param h   High 64 bits of the first 128 bit factor.
    /// @return the converted 64 bit unsigned integer.
    pub fn __fixunstfdi(l: u64, h: u64) -> u64;
}
extern "C" {
    /// Convert long double (which are split as two 64 bit unsigned integers) into 32 bit unsigned integer
    /// @brief Convert long double (which are split as two 64 bit unsigned integers) into 32 bit unsigned integer
    /// @param l   Low 64 bits of the first 128 bit factor.
    /// @param h   High 64 bits of the first 128 bit factor.
    /// @return the converted 32 bit unsigned integer.
    pub fn __fixunstfsi(l: u64, h: u64) -> u32;
}
extern "C" {
    /// Truncate long double (which are split as two 64 bit unsigned integers) into double
    /// @brief Convert long double (which are split as two 64 bit unsigned integers) into double
    /// @param l   Low 64 bits of the first 128 bit factor.
    /// @param h   High 64 bits of the first 128 bit factor.
    /// @return the converted double
    pub fn __trunctfdf2(l: u64, h: u64) -> f64;
}
extern "C" {
    /// Truncate long double (which are split as two 64 bit unsigned integers) into float
    /// @brief Convert long double (which are split as two 64 bit unsigned integers) into float
    /// @param l   Low 64 bits of the first 128 bit factor.
    /// @param h   High 64 bits of the first 128 bit factor.
    /// @return the converted float
    pub fn __trunctfsf2(l: u64, h: u64) -> f32;
}
extern "C" {
    pub fn __break_point();
}
extern "C" {
    /// Tests if the sha256 hash generated from data matches the provided checksum.
    /// This method is optimized to a NO-OP when in fast evaluation mode.
    /// @brief Tests if the sha256 hash generated from data matches the provided checksum.
    ///
    /// @param data - Data you want to hash
    /// @param length - Data length
    /// @param hash - `checksum256*` hash to compare to
    ///
    /// @pre **assert256 hash** of `data` equals provided `hash` parameter.
    /// @post Executes next statement. If was not `true`, hard return.
    ///
    /// Example:
    ///
    /// @code
    /// checksum hash;
    /// char data;
    /// uint32_t length;
    /// assert_sha256( data, length, hash )
    /// //If the sha256 hash generated from data does not equal provided hash, anything below will never fire.
    /// eosio::print("sha256 hash generated from data equals provided hash");
    /// @endcode
    pub fn assert_sha256(
        data: *const ::std::os::raw::c_char,
        length: u32,
        hash: *const checksum256,
    );
}
extern "C" {
    /// Tests if the sha1 hash generated from data matches the provided checksum.
    /// This method is optimized to a NO-OP when in fast evaluation mode.
    /// @brief Tests if the sha1 hash generated from data matches the provided checksum.
    ///
    /// @param data - Data you want to hash
    /// @param length - Data length
    /// @param hash - `checksum160*` hash to compare to
    ///
    /// @pre **sha1 hash** of `data` equals provided `hash` parameter.
    /// @post Executes next statement. If was not `true`, hard return.
    ///
    /// Example:
    ///
    /// @code
    /// checksum hash;
    /// char data;
    /// uint32_t length;
    /// assert_sha1( data, length, hash )
    /// //If the sha1 hash generated from data does not equal provided hash, anything below will never fire.
    /// eosio::print("sha1 hash generated from data equals provided hash");
    /// @endcode
    pub fn assert_sha1(data: *const ::std::os::raw::c_char, length: u32, hash: *const checksum160);
}
extern "C" {
    /// Tests if the sha512 hash generated from data matches the provided checksum.
    /// This method is optimized to a NO-OP when in fast evaluation mode.
    /// @brief Tests if the sha512 hash generated from data matches the provided checksum.
    ///
    /// @param data - Data you want to hash
    /// @param length - Data length
    /// @param hash - `checksum512*` hash to compare to
    ///
    /// @pre **assert512 hash** of `data` equals provided `hash` parameter.
    /// @post Executes next statement. If was not `true`, hard return.
    ///
    /// Example:
    ///
    /// @code
    /// checksum hash;
    /// char data;
    /// uint32_t length;
    /// assert_sha512( data, length, hash )
    /// //If the sha512 hash generated from data does not equal provided hash, anything below will never fire.
    /// eosio::print("sha512 hash generated from data equals provided hash");
    /// @endcode
    pub fn assert_sha512(
        data: *const ::std::os::raw::c_char,
        length: u32,
        hash: *const checksum512,
    );
}
extern "C" {
    /// Tests if the ripemod160 hash generated from data matches the provided checksum.
    /// @brief Tests if the ripemod160 hash generated from data matches the provided checksum.
    ///
    /// @param data - Data you want to hash
    /// @param length - Data length
    /// @param hash - `checksum160*` hash to compare to
    ///
    /// @pre **assert160 hash** of `data` equals provided `hash` parameter.
    /// @post Executes next statement. If was not `true`, hard return.
    ///
    /// Example:
    ///
    /// @code
    /// checksum hash;
    /// char data;
    /// uint32_t length;
    /// assert_ripemod160( data, length, hash )
    /// //If the ripemod160 hash generated from data does not equal provided hash, anything below will never fire.
    /// eosio::print("ripemod160 hash generated from data equals provided hash");
    /// @endcode
    pub fn assert_ripemd160(
        data: *const ::std::os::raw::c_char,
        length: u32,
        hash: *const checksum160,
    );
}
extern "C" {
    /// Hashes `data` using `sha256` and stores result in memory pointed to by hash.
    /// @brief Hashes `data` using `sha256` and stores result in memory pointed to by hash.
    ///
    /// @param data - Data you want to hash
    /// @param length - Data length
    /// @param hash - Hash pointer
    ///
    /// Example:
    ///
    /// @code
    /// checksum calc_hash;
    /// sha256( data, length, &calc_hash );
    /// eos_assert( calc_hash == hash, "invalid hash" );
    /// @endcode
    pub fn sha256(data: *const ::std::os::raw::c_char, length: u32, hash: *mut checksum256);
}
extern "C" {
    /// Hashes `data` using `sha1` and stores result in memory pointed to by hash.
    /// @brief Hashes `data` using `sha1` and stores result in memory pointed to by hash.
    ///
    /// @param data - Data you want to hash
    /// @param length - Data length
    /// @param hash - Hash pointer
    ///
    /// Example:
    ///
    /// @code
    /// checksum calc_hash;
    /// sha1( data, length, &calc_hash );
    /// eos_assert( calc_hash == hash, "invalid hash" );
    /// @endcode
    pub fn sha1(data: *const ::std::os::raw::c_char, length: u32, hash: *mut checksum160);
}
extern "C" {
    /// Hashes `data` using `sha512` and stores result in memory pointed to by hash.
    /// @brief Hashes `data` using `sha512` and stores result in memory pointed to by hash.
    ///
    /// @param data - Data you want to hash
    /// @param length - Data length
    /// @param hash - Hash pointer
    ///
    /// Example:
    ///
    /// @code
    /// checksum calc_hash;
    /// sha512( data, length, &calc_hash );
    /// eos_assert( calc_hash == hash, "invalid hash" );
    /// @endcode
    pub fn sha512(data: *const ::std::os::raw::c_char, length: u32, hash: *mut checksum512);
}
extern "C" {
    /// Hashes `data` using `ripemod160` and stores result in memory pointed to by hash.
    /// @brief Hashes `data` using `ripemod160` and stores result in memory pointed to by hash.
    ///
    /// @param data - Data you want to hash
    /// @param length - Data length
    /// @param hash - Hash pointer
    ///
    /// Example:
    ///
    /// @code
    /// checksum calc_hash;
    /// ripemod160( data, length, &calc_hash );
    /// eos_assert( calc_hash == hash, "invalid hash" );
    /// @endcode
    pub fn ripemd160(data: *const ::std::os::raw::c_char, length: u32, hash: *mut checksum160);
}
extern "C" {
    /// Calculates the public key used for a given signature and hash used to create a message.
    /// @brief Calculates the public key used for a given signature and hash used to create a message.
    ///
    /// @param digest - Hash used to create a message
    /// @param sig - Signature
    /// @param siglen - Signature length
    /// @param pub - Public key
    /// @param publen - Public key length
    ///
    /// Example:
    ///
    /// @code
    /// @endcode
    pub fn recover_key(
        digest: *const checksum256,
        sig: *const ::std::os::raw::c_char,
        siglen: usize,
        pub_: *mut ::std::os::raw::c_char,
        publen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Tests a given public key with the generated key from digest and the signature.
    /// @brief Tests a given public key with the generated key from digest and the signature.
    ///
    /// @param digest - What the key will be generated from
    /// @param sig - Signature
    /// @param siglen - Signature length
    /// @param pub - Public key
    /// @param publen - Public key length
    ///
    /// @pre **assert recovery key** of `pub` equals the key generated from the `digest` parameter
    /// @post Executes next statement. If was not `true`, hard return.
    ///
    /// Example:
    ///
    /// @code
    /// checksum digest;
    /// char sig;
    /// size_t siglen;
    /// char pub;
    /// size_t publen;
    /// assert_recover_key( digest, sig, siglen, pub, publen )
    /// // If the given public key does not match with the generated key from digest and the signature, anything below will never fire.
    /// eosio::print("pub key matches the pub key generated from digest");
    /// @endcode
    pub fn assert_recover_key(
        digest: *const checksum256,
        sig: *const ::std::os::raw::c_char,
        siglen: usize,
        pub_: *const ::std::os::raw::c_char,
        publen: usize,
    );
}
extern "C" {
    /// Store a record in a primary 64-bit integer index table
    ///
    /// @brief Store a record in a primary 64-bit integer index table
    /// @param scope - The scope where the table resides (implied to be within the code of the current receiver)
    /// @param table - The table name
    /// @param payer - The account that pays for the storage costs
    /// @param id - ID of the entry
    /// @param data - Record to store
    /// @param len - Size of data
    /// @pre `data` is a valid pointer to a range of memory at least `len` bytes long
    /// @pre `*((uint64_t*)data)` stores the primary key
    /// @return iterator to the newly created table row
    /// @post a new entry is created in the table
    pub fn db_store_i64(
        scope: account_name,
        table: table_name,
        payer: account_name,
        id: u64,
        data: *const ::std::os::raw::c_void,
        len: u32,
    ) -> i32;
}
extern "C" {
    /// Update a record in a primary 64-bit integer index table
    ///
    /// @brief Update a record in a primary 64-bit integer index table
    /// @param iterator - Iterator to the table row containing the record to update
    /// @param payer - The account that pays for the storage costs (use 0 to continue using current payer)
    /// @param data - New updated record
    /// @param len - Size of data
    /// @pre `data` is a valid pointer to a range of memory at least `len` bytes long
    /// @pre `*((uint64_t*)data)` stores the primary key
    /// @pre `iterator` points to an existing table row in the table
    /// @post the record contained in the table row pointed to by `iterator` is replaced with the new updated record
    pub fn db_update_i64(
        iterator: i32,
        payer: account_name,
        data: *const ::std::os::raw::c_void,
        len: u32,
    );
}
extern "C" {
    /// Remove a record from a primary 64-bit integer index table
    ///
    /// @brief Remove a record from a primary 64-bit integer index table
    /// @param iterator - Iterator to the table row to remove
    /// @pre `iterator` points to an existing table row in the table
    /// @post the table row pointed to by `iterator` is removed and the associated storage costs are refunded to the payer
    ///
    /// Example:
    ///
    /// @code
    /// int32_t itr = db_find_i64(receiver, receiver, table1, N(alice));
    /// eosio_assert(itr >= 0, "Alice cannot be removed since she was already not found in the table");
    /// db_remove_i64(itr);
    /// @endcode
    pub fn db_remove_i64(iterator: i32);
}
extern "C" {
    /// Get a record in a primary 64-bit integer index table
    ///
    /// @brief Get a record in a primary 64-bit integer index table
    /// @param iterator - The iterator to the table row containing the record to retrieve
    /// @param data - Pointer to the buffer which will be filled with the retrieved record
    /// @param len - Size of the buffer
    /// @return size of the data copied into the buffer if `len > 0`, or size of the retrieved record if `len == 0`.
    /// @pre `iterator` points to an existing table row in the table
    /// @pre `data` is a valid pointer to a range of memory at least `len` bytes long
    /// @post `data` will be filled with the retrieved record (truncated to the first `len` bytes if necessary)
    ///
    /// Example:
    ///
    /// @code
    /// char value[50];
    /// auto len = db_get_i64(itr, value, 0);
    /// eosio_assert(len <= 50, "buffer to small to store retrieved record");
    /// db_get_i64(itr, value, len);
    /// @endcode
    pub fn db_get_i64(iterator: i32, data: *const ::std::os::raw::c_void, len: u32) -> i32;
}
extern "C" {
    /// Find the table row following the referenced table row in a primary 64-bit integer index table
    ///
    /// @brief Find the table row following the referenced table row in a primary 64-bit integer index table
    /// @param iterator - The iterator to the referenced table row
    /// @param primary - Pointer to a `uint64_t` variable which will have its value set to the primary key of the next table row
    /// @return iterator to the table row following the referenced table row (or the end iterator of the table if the referenced table row is the last one in the table)
    /// @pre `iterator` points to an existing table row in the table
    /// @post `*primary` will be replaced with the primary key of the table row following the referenced table row if it exists, otherwise `*primary` will be left untouched
    ///
    /// Example:
    ///
    /// @code
    /// int32_t charlie_itr = db_find_i64(receiver, receiver, table1, N(charlie));
    /// // expect nothing after charlie
    /// uint64_t prim = 0
    /// int32_t  end_itr = db_next_i64(charlie_itr, &prim);
    /// eosio_assert(end_itr < -1, "Charlie was not the last entry in the table");
    /// @endcode
    pub fn db_next_i64(iterator: i32, primary: *mut u64) -> i32;
}
extern "C" {
    /// Find the table row preceding the referenced table row in a primary 64-bit integer index table
    ///
    /// @brief Find the table row preceding the referenced table row in a primary 64-bit integer index table
    /// @param iterator - The iterator to the referenced table row
    /// @param primary - Pointer to a `uint64_t` variable which will have its value set to the primary key of the previous table row
    /// @return iterator to the table row preceding the referenced table row assuming one exists (it will return -1 if the referenced table row is the first one in the table)
    /// @pre `iterator` points to an existing table row in the table or it is the end iterator of the table
    /// @post `*primary` will be replaced with the primary key of the table row preceding the referenced table row if it exists, otherwise `*primary` will be left untouched
    ///
    /// Example:
    ///
    /// @code
    /// uint64_t prim = 0;
    /// int32_t  itr_prev = db_previous_i64(itr, &prim);
    /// @endcode
    pub fn db_previous_i64(iterator: i32, primary: *mut u64) -> i32;
}
extern "C" {
    /// Find a table row in a primary 64-bit integer index table by primary key
    ///
    /// @brief Find a table row in a primary 64-bit integer index table by primary key
    /// @param code - The name of the owner of the table
    /// @param scope - The scope where the table resides
    /// @param table - The table name
    /// @param id - The primary key of the table row to look up
    /// @return iterator to the table row with a primary key equal to `id` or the end iterator of the table if the table row could not be found
    ///
    /// Example:
    ///
    /// @code
    /// int itr = db_find_i64(receiver, receiver, table1, N(charlie));
    /// @endcode
    pub fn db_find_i64(code: account_name, scope: account_name, table: table_name, id: u64) -> i32;
}
extern "C" {
    /// Find the table row in a primary 64-bit integer index table that matches the lowerbound condition for a given primary key
    /// The table row that matches the lowerbound condition is the first table row in the table with the lowest primary key that is >= the given key
    ///
    /// @brief Find the table row in a primary 64-bit integer index table that matches the lowerbound condition for a given primary key
    /// @param code - The name of the owner of the table
    /// @param scope - The scope where the table resides
    /// @param table - The table name
    /// @param id - The primary key used to determine the lowerbound
    /// @return iterator to the found table row or the end iterator of the table if the table row could not be found
    pub fn db_lowerbound_i64(
        code: account_name,
        scope: account_name,
        table: table_name,
        id: u64,
    ) -> i32;
}
extern "C" {
    /// Find the table row in a primary 64-bit integer index table that matches the upperbound condition for a given primary key
    /// The table row that matches the upperbound condition is the first table row in the table with the lowest primary key that is > the given key
    ///
    /// @brief Find the table row in a primary 64-bit integer index table that matches the upperbound condition for a given primary key
    /// @param code - The name of the owner of the table
    /// @param scope - The scope where the table resides
    /// @param table - The table name
    /// @param id - The primary key used to determine the upperbound
    /// @return iterator to the found table row or the end iterator of the table if the table row could not be found
    pub fn db_upperbound_i64(
        code: account_name,
        scope: account_name,
        table: table_name,
        id: u64,
    ) -> i32;
}
extern "C" {
    /// Get an iterator representing just-past-the-end of the last table row of a primary 64-bit integer index table
    ///
    /// @brief Get an iterator representing just-past-the-end of the last table row of a primary 64-bit integer index table
    /// @param code - The name of the owner of the table
    /// @param scope - The scope where the table resides
    /// @param table - The table name
    /// @return end iterator of the table
    pub fn db_end_i64(code: account_name, scope: account_name, table: table_name) -> i32;
}
extern "C" {
    /// Store an association of a 64-bit integer secondary key to a primary key in a secondary 64-bit integer index table
    ///
    /// @brief Store an association of a 64-bit integer secondary key to a primary key in a secondary 64-bit integer index table
    /// @param scope - The scope where the table resides (implied to be within the code of the current receiver)
    /// @param table - The table name
    /// @param payer - The account that pays for the storage costs
    /// @param id - The primary key to which to associate the secondary key
    /// @param secondary - Pointer to the secondary key
    /// @return iterator to the newly created table row
    /// @post new secondary key association between primary key `id` and secondary key `*secondary` is created in the secondary 64-bit integer index table
    pub fn db_idx64_store(
        scope: account_name,
        table: table_name,
        payer: account_name,
        id: u64,
        secondary: *const u64,
    ) -> i32;
}
extern "C" {
    /// Update an association for a 64-bit integer secondary key to a primary key in a secondary 64-bit integer index table
    ///
    /// @brief Update an association for a 64-bit integer secondary key to a primary key in a secondary 64-bit integer index table
    /// @param iterator - The iterator to the table row containing the secondary key association to update
    /// @param payer - The account that pays for the storage costs (use 0 to continue using current payer)
    /// @param secondary - Pointer to the **new** secondary key that will replace the existing one of the association
    /// @pre `iterator` points to an existing table row in the table
    /// @post the secondary key of the table row pointed to by `iterator` is replaced by `*secondary`
    pub fn db_idx64_update(iterator: i32, payer: account_name, secondary: *const u64);
}
extern "C" {
    /// Remove a table row from a secondary 64-bit integer index table
    ///
    /// @brief Remove a table row from a secondary 64-bit integer index table
    /// @param iterator - Iterator to the table row to remove
    /// @pre `iterator` points to an existing table row in the table
    /// @post the table row pointed to by `iterator` is removed and the associated storage costs are refunded to the payer
    pub fn db_idx64_remove(iterator: i32);
}
extern "C" {
    /// Find the table row following the referenced table row in a secondary 64-bit integer index table
    ///
    /// @brief Find the table row following the referenced table row in a secondary 64-bit integer index table
    /// @param iterator - The iterator to the referenced table row
    /// @param primary - Pointer to a `uint64_t` variable which will have its value set to the primary key of the next table row
    /// @return iterator to the table row following the referenced table row (or the end iterator of the table if the referenced table row is the last one in the table)
    /// @pre `iterator` points to an existing table row in the table
    /// @post `*primary` will be replaced with the primary key of the table row following the referenced table row if it exists, otherwise `*primary` will be left untouched
    pub fn db_idx64_next(iterator: i32, primary: *mut u64) -> i32;
}
extern "C" {
    /// Find the table row preceding the referenced table row in a secondary 64-bit integer index table
    ///
    /// @brief Find the table row preceding the referenced table row in a secondary 64-bit integer index table
    /// @param iterator - The iterator to the referenced table row
    /// @param primary - Pointer to a `uint64_t` variable which will have its value set to the primary key of the previous table row
    /// @return iterator to the table row preceding the referenced table row assuming one exists (it will return -1 if the referenced table row is the first one in the table)
    /// @pre `iterator` points to an existing table row in the table or it is the end iterator of the table
    /// @post `*primary` will be replaced with the primary key of the table row preceding the referenced table row if it exists, otherwise `*primary` will be left untouched
    pub fn db_idx64_previous(iterator: i32, primary: *mut u64) -> i32;
}
extern "C" {
    /// Find a table row in a secondary 64-bit integer index table by primary key
    ///
    /// @brief Find a table row in a secondary 64-bit integer index table by primary key
    /// @param code - The name of the owner of the table
    /// @param scope - The scope where the table resides
    /// @param table - The table name
    /// @param secondary - Pointer to a `uint64_t` variable which will have its value set to the secondary key of the found table row
    /// @param primary - The primary key of the table row to look up
    /// @post If and only if the table row is found, `*secondary` will be replaced with the secondary key of the found table row
    /// @return iterator to the table row with a primary key equal to `id` or the end iterator of the table if the table row could not be found
    pub fn db_idx64_find_primary(
        code: account_name,
        scope: account_name,
        table: table_name,
        secondary: *mut u64,
        primary: u64,
    ) -> i32;
}
extern "C" {
    /// Find a table row in a secondary 64-bit integer index table by secondary key
    ///
    /// @brief Find a table row in a secondary 64-bit integer index table by secondary key
    /// @param code - The name of the owner of the table
    /// @param scope - The scope where the table resides
    /// @param table - The table name
    /// @param secondary - Pointer to secondary key used to lookup the table row
    /// @param primary - Pointer to a `uint64_t` variable which will have its value set to the primary key of the found table row
    /// @post If and only if the table row is found, `*primary` will be replaced with the primary key of the found table row
    /// @return iterator to the first table row with a secondary key equal to `*secondary` or the end iterator of the table if the table row could not be found
    pub fn db_idx64_find_secondary(
        code: account_name,
        scope: account_name,
        table: table_name,
        secondary: *const u64,
        primary: *mut u64,
    ) -> i32;
}
extern "C" {
    /// Find the table row in a secondary 64-bit integer index table that matches the lowerbound condition for a given secondary key
    /// The table row that matches the lowerbound condition is the first table row in the table with the lowest secondary key that is >= the given key
    ///
    /// @brief Find the table row in a secondary 64-bit integer index table that matches the lowerbound condition for a given secondary key
    /// @param code - The name of the owner of the table
    /// @param scope - The scope where the table resides
    /// @param table - The table name
    /// @param secondary - Pointer to secondary key first used to determine the lowerbound and which is then replaced with the secondary key of the found table row
    /// @param primary - Pointer to a `uint64_t` variable which will have its value set to the primary key of the found table row
    /// @post If and only if the table row is found, `*secondary` will be replaced with the secondary key of the found table row
    /// @post If and only if the table row is found, `*primary` will be replaced with the primary key of the found table row
    /// @return iterator to the found table row or the end iterator of the table if the table row could not be found
    pub fn db_idx64_lowerbound(
        code: account_name,
        scope: account_name,
        table: table_name,
        secondary: *mut u64,
        primary: *mut u64,
    ) -> i32;
}
extern "C" {
    /// Find the table row in a secondary 64-bit integer index table that matches the upperbound condition for a given secondary key
    /// The table row that matches the upperbound condition is the first table row in the table with the lowest secondary key that is > the given key
    ///
    /// @brief Find the table row in a secondary 64-bit integer index table that matches the upperbound condition for a given secondary key
    /// @param code - The name of the owner of the table
    /// @param scope - The scope where the table resides
    /// @param table - The table name
    /// @param secondary - Pointer to secondary key first used to determine the upperbound and which is then replaced with the secondary key of the found table row
    /// @param primary - Pointer to a `uint64_t` variable which will have its value set to the primary key of the found table row
    /// @post If and only if the table row is found, `*secondary` will be replaced with the secondary key of the found table row
    /// @post If and only if the table row is found, `*primary` will be replaced with the primary key of the found table row
    /// @return iterator to the found table row or the end iterator of the table if the table row could not be found
    pub fn db_idx64_upperbound(
        code: account_name,
        scope: account_name,
        table: table_name,
        secondary: *mut u64,
        primary: *mut u64,
    ) -> i32;
}
extern "C" {
    /// Get an end iterator representing just-past-the-end of the last table row of a secondary 64-bit integer index table
    ///
    /// @brief Get an end iterator representing just-past-the-end of the last table row of a secondary 64-bit integer index table
    /// @param code - The name of the owner of the table
    /// @param scope - The scope where the table resides
    /// @param table - The table name
    /// @return end iterator of the table
    pub fn db_idx64_end(code: account_name, scope: account_name, table: table_name) -> i32;
}
extern "C" {
    /// Store an association of a 128-bit integer secondary key to a primary key in a secondary 128-bit integer index table
    ///
    /// @brief Store an association of a 128-bit integer secondary key to a primary key in a secondary 128-bit integer index table
    /// @param scope - The scope where the table resides (implied to be within the code of the current receiver)
    /// @param table - The table name
    /// @param payer - The account that pays for the storage costs
    /// @param id - The primary key to which to associate the secondary key
    /// @param secondary - Pointer to the secondary key
    /// @return iterator to the newly created table row
    /// @post new secondary key association between primary key `id` and secondary key `*secondary` is created in the secondary 128-bit integer index table
    pub fn db_idx128_store(
        scope: account_name,
        table: table_name,
        payer: account_name,
        id: u64,
        secondary: *const uint128_t,
    ) -> i32;
}
extern "C" {
    /// Update an association for a 128-bit integer secondary key to a primary key in a secondary 128-bit integer index table
    ///
    /// @brief Update an association for a 128-bit integer secondary key to a primary key in a secondary 128-bit integer index table
    /// @param iterator - The iterator to the table row containing the secondary key association to update
    /// @param payer - The account that pays for the storage costs (use 0 to continue using current payer)
    /// @param secondary - Pointer to the **new** secondary key that will replace the existing one of the association
    /// @pre `iterator` points to an existing table row in the table
    /// @post the secondary key of the table row pointed to by `iterator` is replaced by `*secondary`
    pub fn db_idx128_update(iterator: i32, payer: account_name, secondary: *const uint128_t);
}
extern "C" {
    /// Remove a table row from a secondary 128-bit integer index table
    ///
    /// @brief Remove a table row from a secondary 128-bit integer index table
    /// @param iterator - Iterator to the table row to remove
    /// @pre `iterator` points to an existing table row in the table
    /// @post the table row pointed to by `iterator` is removed and the associated storage costs are refunded to the payer
    pub fn db_idx128_remove(iterator: i32);
}
extern "C" {
    /// Find the table row following the referenced table row in a secondary 128-bit integer index table
    ///
    /// @brief Find the table row following the referenced table row in a secondary 128-bit integer index table
    /// @param iterator - The iterator to the referenced table row
    /// @param primary - Pointer to a `uint64_t` variable which will have its value set to the primary key of the next table row
    /// @return iterator to the table row following the referenced table row (or the end iterator of the table if the referenced table row is the last one in the table)
    /// @pre `iterator` points to an existing table row in the table
    /// @post `*primary` will be replaced with the primary key of the table row following the referenced table row if it exists, otherwise `*primary` will be left untouched
    pub fn db_idx128_next(iterator: i32, primary: *mut u64) -> i32;
}
extern "C" {
    /// Find the table row preceding the referenced table row in a secondary 128-bit integer index table
    ///
    /// @brief Find the table row preceding the referenced table row in a secondary 128-bit integer index table
    /// @param iterator - The iterator to the referenced table row
    /// @param primary - Pointer to a `uint64_t` variable which will have its value set to the primary key of the previous table row
    /// @return iterator to the table row preceding the referenced table row assuming one exists (it will return -1 if the referenced table row is the first one in the table)
    /// @pre `iterator` points to an existing table row in the table or it is the end iterator of the table
    /// @post `*primary` will be replaced with the primary key of the table row preceding the referenced table row if it exists, otherwise `*primary` will be left untouched
    pub fn db_idx128_previous(iterator: i32, primary: *mut u64) -> i32;
}
extern "C" {
    /// Find a table row in a secondary 128-bit integer index table by primary key
    ///
    /// @brief Find a table row in a secondary 128-bit integer index table by primary key
    /// @param code - The name of the owner of the table
    /// @param scope - The scope where the table resides
    /// @param table - The table name
    /// @param secondary - Pointer to a `uint128_t` variable which will have its value set to the secondary key of the found table row
    /// @param primary - The primary key of the table row to look up
    /// @post If and only if the table row is found, `*secondary` will be replaced with the secondary key of the found table row
    /// @return iterator to the table row with a primary key equal to `id` or the end iterator of the table if the table row could not be found
    pub fn db_idx128_find_primary(
        code: account_name,
        scope: account_name,
        table: table_name,
        secondary: *mut uint128_t,
        primary: u64,
    ) -> i32;
}
extern "C" {
    /// Find a table row in a secondary 128-bit integer index table by secondary key
    ///
    /// @brief Find a table row in a secondary 128-bit integer index table by secondary key
    /// @param code - The name of the owner of the table
    /// @param scope - The scope where the table resides
    /// @param table - The table name
    /// @param secondary - Pointer to secondary key used to lookup the table row
    /// @param primary - Pointer to a `uint64_t` variable which will have its value set to the primary key of the found table row
    /// @post If and only if the table row is found, `*primary` will be replaced with the primary key of the found table row
    /// @return iterator to the first table row with a secondary key equal to `*secondary` or the end iterator of the table if the table row could not be found
    pub fn db_idx128_find_secondary(
        code: account_name,
        scope: account_name,
        table: table_name,
        secondary: *const uint128_t,
        primary: *mut u64,
    ) -> i32;
}
extern "C" {
    /// Find the table row in a secondary 128-bit integer index table that matches the lowerbound condition for a given secondary key
    /// The table row that matches the lowerbound condition is the first table row in the table with the lowest secondary key that is >= the given key
    ///
    /// @brief Find the table row in a secondary 128-bit integer index table that matches the lowerbound condition for a given secondary key
    /// @param code - The name of the owner of the table
    /// @param scope - The scope where the table resides
    /// @param table - The table name
    /// @param secondary - Pointer to secondary key first used to determine the lowerbound and which is then replaced with the secondary key of the found table row
    /// @param primary - Pointer to a `uint64_t` variable which will have its value set to the primary key of the found table row
    /// @post If and only if the table row is found, `*secondary` will be replaced with the secondary key of the found table row
    /// @post If and only if the table row is found, `*primary` will be replaced with the primary key of the found table row
    /// @return iterator to the found table row or the end iterator of the table if the table row could not be found
    pub fn db_idx128_lowerbound(
        code: account_name,
        scope: account_name,
        table: table_name,
        secondary: *mut uint128_t,
        primary: *mut u64,
    ) -> i32;
}
extern "C" {
    /// Find the table row in a secondary 128-bit integer index table that matches the upperbound condition for a given secondary key
    /// The table row that matches the upperbound condition is the first table row in the table with the lowest secondary key that is > the given key
    ///
    /// @brief Find the table row in a secondary 128-bit integer index table that matches the upperbound condition for a given secondary key
    /// @param code - The name of the owner of the table
    /// @param scope - The scope where the table resides
    /// @param table - The table name
    /// @param secondary - Pointer to secondary key first used to determine the upperbound and which is then replaced with the secondary key of the found table row
    /// @param primary - Pointer to a `uint64_t` variable which will have its value set to the primary key of the found table row
    /// @post If and only if the table row is found, `*secondary` will be replaced with the secondary key of the found table row
    /// @post If and only if the table row is found, `*primary` will be replaced with the primary key of the found table row
    /// @return iterator to the found table row or the end iterator of the table if the table row could not be found
    pub fn db_idx128_upperbound(
        code: account_name,
        scope: account_name,
        table: table_name,
        secondary: *mut uint128_t,
        primary: *mut u64,
    ) -> i32;
}
extern "C" {
    /// Get an end iterator representing just-past-the-end of the last table row of a secondary 128-bit integer index table
    ///
    /// @brief Get an end iterator representing just-past-the-end of the last table row of a secondary 128-bit integer index table
    /// @param code - The name of the owner of the table
    /// @param scope - The scope where the table resides
    /// @param table - The table name
    /// @return end iterator of the table
    pub fn db_idx128_end(code: account_name, scope: account_name, table: table_name) -> i32;
}
extern "C" {
    /// Store an association of a 256-bit secondary key to a primary key in a secondary 256-bit index table
    ///
    /// @brief Store an association of a 256-bit secondary key to a primary key in a secondary 256-bit index table
    /// @param scope - The scope where the table resides (implied to be within the code of the current receiver)
    /// @param table - The table name
    /// @param payer - The account that pays for the storage costs
    /// @param id - The primary key to which to associate the secondary key
    /// @param data - Pointer to the secondary key data stored as an array of 2 `uint128_t` integers
    /// @param data_len - Must be set to 2
    /// @return iterator to the newly created table row
    /// @post new secondary key association between primary key `id` and the specified secondary key is created in the secondary 256-bit index table
    pub fn db_idx256_store(
        scope: account_name,
        table: table_name,
        payer: account_name,
        id: u64,
        data: *const uint128_t,
        data_len: u32,
    ) -> i32;
}
extern "C" {
    /// Update an association for a 256-bit secondary key to a primary key in a secondary 256-bit index table
    ///
    /// @brief Update an association for a 256-bit secondary key to a primary key in a secondary 256-bit index table
    /// @param iterator - The iterator to the table row containing the secondary key association to update
    /// @param payer - The account that pays for the storage costs (use 0 to continue using current payer)
    /// @param data - Pointer to the **new** secondary key data (which is stored as an array of 2 `uint128_t` integers) that will replace the existing one of the association
    /// @param data_len - Must be set to 2
    /// @pre `iterator` points to an existing table row in the table
    /// @post the secondary key of the table row pointed to by `iterator` is replaced by the specified secondary key
    pub fn db_idx256_update(
        iterator: i32,
        payer: account_name,
        data: *const uint128_t,
        data_len: u32,
    );
}
extern "C" {
    /// Remove a table row from a secondary 256-bit index table
    ///
    /// @brief Remove a table row from a secondary 256-bit index table
    /// @param iterator - Iterator to the table row to remove
    /// @pre `iterator` points to an existing table row in the table
    /// @post the table row pointed to by `iterator` is removed and the associated storage costs are refunded to the payer
    pub fn db_idx256_remove(iterator: i32);
}
extern "C" {
    /// Find the table row following the referenced table row in a secondary 256-bit index table
    ///
    /// @brief Find the table row following the referenced table row in a secondary 256-bit index table
    /// @param iterator - The iterator to the referenced table row
    /// @param primary - Pointer to a `uint64_t` variable which will have its value set to the primary key of the next table row
    /// @return iterator to the table row following the referenced table row (or the end iterator of the table if the referenced table row is the last one in the table)
    /// @pre `iterator` points to an existing table row in the table
    /// @post `*primary` will be replaced with the primary key of the table row following the referenced table row if it exists, otherwise `*primary` will be left untouched
    pub fn db_idx256_next(iterator: i32, primary: *mut u64) -> i32;
}
extern "C" {
    /// Find the table row preceding the referenced table row in a secondary 256-bit index table
    ///
    /// @brief Find the table row preceding the referenced table row in a secondary 256-bit index table
    /// @param iterator - The iterator to the referenced table row
    /// @param primary - Pointer to a `uint64_t` variable which will have its value set to the primary key of the previous table row
    /// @return iterator to the table row preceding the referenced table row assuming one exists (it will return -1 if the referenced table row is the first one in the table)
    /// @pre `iterator` points to an existing table row in the table or it is the end iterator of the table
    /// @post `*primary` will be replaced with the primary key of the table row preceding the referenced table row if it exists, otherwise `*primary` will be left untouched
    pub fn db_idx256_previous(iterator: i32, primary: *mut u64) -> i32;
}
extern "C" {
    /// Find a table row in a secondary 256-bit index table by primary key
    ///
    /// @brief Find a table row in a secondary 128-bit integer index table by primary key
    /// @param code - The name of the owner of the table
    /// @param scope - The scope where the table resides
    /// @param table - The table name
    /// @param data - Pointer to the an array of 2 `uint128_t` integers which will act as the buffer to hold the retrieved secondary key of the found table row
    /// @param data_len - Must be set to 2
    /// @param primary - The primary key of the table row to look up
    /// @post If and only if the table row is found, the buffer pointed to by `data` will be filled with the secondary key of the found table row
    /// @return iterator to the table row with a primary key equal to `id` or the end iterator of the table if the table row could not be found
    pub fn db_idx256_find_primary(
        code: account_name,
        scope: account_name,
        table: table_name,
        data: *mut uint128_t,
        data_len: u32,
        primary: u64,
    ) -> i32;
}
extern "C" {
    /// Find a table row in a secondary 256-bit index table by secondary key
    ///
    /// @brief Find a table row in a secondary 256-bit index table by secondary key
    /// @param code - The name of the owner of the table
    /// @param scope - The scope where the table resides
    /// @param table - The table name
    /// @param data - Pointer to the secondary key data (which is stored as an array of 2 `uint128_t` integers) used to lookup the table row
    /// @param data_len - Must be set to 2
    /// @param primary - Pointer to a `uint64_t` variable which will have its value set to the primary key of the found table row
    /// @post If and only if the table row is found, `*primary` will be replaced with the primary key of the found table row
    /// @return iterator to the first table row with a secondary key equal to the specified secondary key or the end iterator of the table if the table row could not be found
    pub fn db_idx256_find_secondary(
        code: account_name,
        scope: account_name,
        table: table_name,
        data: *const uint128_t,
        data_len: u32,
        primary: *mut u64,
    ) -> i32;
}
extern "C" {
    /// Find the table row in a secondary 256-bit index table that matches the lowerbound condition for a given secondary key
    /// The table row that matches the lowerbound condition is the first table row in the table with the lowest secondary key that is >= the given key (uses lexicographical ordering on the 256-bit keys)
    ///
    /// @brief Find the table row in a secondary 256-bit index table that matches the lowerbound condition for a given secondary key
    /// @param code - The name of the owner of the table
    /// @param scope - The scope where the table resides
    /// @param table - The table name
    /// @param data - Pointer to the secondary key data (which is stored as an array of 2 `uint128_t` integers) first used to determine the lowerbound and which is then replaced with the secondary key of the found table row
    /// @param data_len - Must be set to 2
    /// @param primary - Pointer to a `uint64_t` variable which will have its value set to the primary key of the found table row
    /// @post If and only if the table row is found, the buffer pointed to by `data` will be filled with the secondary key of the found table row
    /// @post If and only if the table row is found, `*primary` will be replaced with the primary key of the found table row
    /// @return iterator to the found table row or the end iterator of the table if the table row could not be found
    pub fn db_idx256_lowerbound(
        code: account_name,
        scope: account_name,
        table: table_name,
        data: *mut uint128_t,
        data_len: u32,
        primary: *mut u64,
    ) -> i32;
}
extern "C" {
    /// Find the table row in a secondary 256-bit index table that matches the upperbound condition for a given secondary key
    /// The table row that matches the upperbound condition is the first table row in the table with the lowest secondary key that is > the given key (uses lexicographical ordering on the 256-bit keys)
    ///
    /// @brief Find the table row in a secondary 256-bit index table that matches the upperbound condition for a given secondary key
    /// @param code - The name of the owner of the table
    /// @param scope - The scope where the table resides
    /// @param table - The table name
    /// @param data - Pointer to the secondary key data (which is stored as an array of 2 `uint128_t` integers) first used to determine the upperbound and which is then replaced with the secondary key of the found table row
    /// @param data_len - Must be set to 2
    /// @param primary - Pointer to a `uint64_t` variable which will have its value set to the primary key of the found table row
    /// @post If and only if the table row is found, the buffer pointed to by `data` will be filled with the secondary key of the found table row
    /// @post If and only if the table row is found, `*primary` will be replaced with the primary key of the found table row
    /// @return iterator to the found table row or the end iterator of the table if the table row could not be found
    pub fn db_idx256_upperbound(
        code: account_name,
        scope: account_name,
        table: table_name,
        data: *mut uint128_t,
        data_len: u32,
        primary: *mut u64,
    ) -> i32;
}
extern "C" {
    /// Get an end iterator representing just-past-the-end of the last table row of a secondary 256-bit index table
    ///
    /// @brief Get an end iterator representing just-past-the-end of the last table row of a secondary 256-bit index table
    /// @param code - The name of the owner of the table
    /// @param scope - The scope where the table resides
    /// @param table - The table name
    /// @return end iterator of the table
    pub fn db_idx256_end(code: account_name, scope: account_name, table: table_name) -> i32;
}
extern "C" {
    /// Store an association of a double-precision floating-point secondary key to a primary key in a secondary double-precision floating-point index table
    ///
    /// @brief Store an association of a double-precision floating-point secondary key to a primary key in a secondary double-precision floating-point index table
    /// @param scope - The scope where the table resides (implied to be within the code of the current receiver)
    /// @param table - The table name
    /// @param payer - The account that pays for the storage costs
    /// @param id - The primary key to which to associate the secondary key
    /// @param secondary - Pointer to the secondary key
    /// @return iterator to the newly created table row
    /// @post new secondary key association between primary key `id` and secondary key `*secondary` is created in the secondary double-precision floating-point index table
    pub fn db_idx_double_store(
        scope: account_name,
        table: table_name,
        payer: account_name,
        id: u64,
        secondary: *const f64,
    ) -> i32;
}
extern "C" {
    /// Update an association for a double-precision floating-point secondary key to a primary key in a secondary double-precision floating-point index table
    ///
    /// @brief Update an association for a double-precision floating-point secondary key to a primary key in a secondary double-precision floating-point index table
    /// @param iterator - The iterator to the table row containing the secondary key association to update
    /// @param payer - The account that pays for the storage costs (use 0 to continue using current payer)
    /// @param secondary - Pointer to the **new** secondary key that will replace the existing one of the association
    /// @pre `iterator` points to an existing table row in the table
    /// @post the secondary key of the table row pointed to by `iterator` is replaced by `*secondary`
    pub fn db_idx_double_update(iterator: i32, payer: account_name, secondary: *const f64);
}
extern "C" {
    /// Remove a table row from a secondary double-precision floating-point index table
    ///
    /// @brief Remove a table row from a secondary double-precision floating-point index table
    /// @param iterator - Iterator to the table row to remove
    /// @pre `iterator` points to an existing table row in the table
    /// @post the table row pointed to by `iterator` is removed and the associated storage costs are refunded to the payer
    pub fn db_idx_double_remove(iterator: i32);
}
extern "C" {
    /// Find the table row following the referenced table row in a secondary double-precision floating-point index table
    ///
    /// @brief Find the table row following the referenced table row in a secondary double-precision floating-point index table
    /// @param iterator - The iterator to the referenced table row
    /// @param primary - Pointer to a `uint64_t` variable which will have its value set to the primary key of the next table row
    /// @return iterator to the table row following the referenced table row (or the end iterator of the table if the referenced table row is the last one in the table)
    /// @pre `iterator` points to an existing table row in the table
    /// @post `*primary` will be replaced with the primary key of the table row following the referenced table row if it exists, otherwise `*primary` will be left untouched
    pub fn db_idx_double_next(iterator: i32, primary: *mut u64) -> i32;
}
extern "C" {
    /// Find the table row preceding the referenced table row in a secondary double-precision floating-point index table
    ///
    /// @brief Find the table row preceding the referenced table row in a secondary double-precision floating-point index table
    /// @param iterator - The iterator to the referenced table row
    /// @param primary - Pointer to a `uint64_t` variable which will have its value set to the primary key of the previous table row
    /// @return iterator to the table row preceding the referenced table row assuming one exists (it will return -1 if the referenced table row is the first one in the table)
    /// @pre `iterator` points to an existing table row in the table or it is the end iterator of the table
    /// @post `*primary` will be replaced with the primary key of the table row preceding the referenced table row if it exists, otherwise `*primary` will be left untouched
    pub fn db_idx_double_previous(iterator: i32, primary: *mut u64) -> i32;
}
extern "C" {
    /// Find a table row in a secondary double-precision floating-point index table by primary key
    ///
    /// @brief Find a table row in a secondary double-precision floating-point index table by primary key
    /// @param code - The name of the owner of the table
    /// @param scope - The scope where the table resides
    /// @param table - The table name
    /// @param secondary - Pointer to a `double` variable which will have its value set to the secondary key of the found table row
    /// @param primary - The primary key of the table row to look up
    /// @post If and only if the table row is found, `*secondary` will be replaced with the secondary key of the found table row
    /// @return iterator to the table row with a primary key equal to `id` or the end iterator of the table if the table row could not be found
    pub fn db_idx_double_find_primary(
        code: account_name,
        scope: account_name,
        table: table_name,
        secondary: *mut f64,
        primary: u64,
    ) -> i32;
}
extern "C" {
    /// Find a table row in a secondary double-precision floating-point index table by secondary key
    ///
    /// @brief Find a table row in a secondary double-precision floating-point index table by secondary key
    /// @param code - The name of the owner of the table
    /// @param scope - The scope where the table resides
    /// @param table - The table name
    /// @param secondary - Pointer to secondary key used to lookup the table row
    /// @param primary - Pointer to a `double` variable which will have its value set to the primary key of the found table row
    /// @post If and only if the table row is found, `*primary` will be replaced with the primary key of the found table row
    /// @return iterator to the first table row with a secondary key equal to `*secondary` or the end iterator of the table if the table row could not be found
    pub fn db_idx_double_find_secondary(
        code: account_name,
        scope: account_name,
        table: table_name,
        secondary: *const f64,
        primary: *mut u64,
    ) -> i32;
}
extern "C" {
    /// Find the table row in a secondary double-precision floating-point index table that matches the lowerbound condition for a given secondary key
    /// The table row that matches the lowerbound condition is the first table row in the table with the lowest secondary key that is >= the given key
    ///
    /// @brief Find the table row in a secondary double-precision floating-point index table that matches the lowerbound condition for a given secondary key
    /// @param code - The name of the owner of the table
    /// @param scope - The scope where the table resides
    /// @param table - The table name
    /// @param secondary - Pointer to secondary key first used to determine the lowerbound and which is then replaced with the secondary key of the found table row
    /// @param primary - Pointer to a `uint64_t` variable which will have its value set to the primary key of the found table row
    /// @post If and only if the table row is found, `*secondary` will be replaced with the secondary key of the found table row
    /// @post If and only if the table row is found, `*primary` will be replaced with the primary key of the found table row
    /// @return iterator to the found table row or the end iterator of the table if the table row could not be found
    pub fn db_idx_double_lowerbound(
        code: account_name,
        scope: account_name,
        table: table_name,
        secondary: *mut f64,
        primary: *mut u64,
    ) -> i32;
}
extern "C" {
    /// Find the table row in a secondary double-precision floating-point index table that matches the upperbound condition for a given secondary key
    /// The table row that matches the upperbound condition is the first table row in the table with the lowest secondary key that is > the given key
    ///
    /// @brief Find the table row in a secondary double-precision floating-point index table that matches the upperbound condition for a given secondary key
    /// @param code - The name of the owner of the table
    /// @param scope - The scope where the table resides
    /// @param table - The table name
    /// @param secondary - Pointer to secondary key first used to determine the upperbound and which is then replaced with the secondary key of the found table row
    /// @param primary - Pointer to a `uint64_t` variable which will have its value set to the primary key of the found table row
    /// @post If and only if the table row is found, `*secondary` will be replaced with the secondary key of the found table row
    /// @post If and only if the table row is found, `*primary` will be replaced with the primary key of the found table row
    /// @return iterator to the found table row or the end iterator of the table if the table row could not be found
    pub fn db_idx_double_upperbound(
        code: account_name,
        scope: account_name,
        table: table_name,
        secondary: *mut f64,
        primary: *mut u64,
    ) -> i32;
}
extern "C" {
    /// Get an end iterator representing just-past-the-end of the last table row of a secondary double-precision floating-point index table
    ///
    /// @brief Get an end iterator representing just-past-the-end of the last table row of a secondary double-precision floating-point index table
    /// @param code - The name of the owner of the table
    /// @param scope - The scope where the table resides
    /// @param table - The table name
    /// @return end iterator of the table
    pub fn db_idx_double_end(code: account_name, scope: account_name, table: table_name) -> i32;
}
extern "C" {
    /// Store an association of a quadruple-precision floating-point secondary key to a primary key in a secondary quadruple-precision floating-point index table
    ///
    /// @brief Store an association of a quadruple-precision floating-point secondary key to a primary key in a secondary quadruple-precision floating-point index table
    /// @param scope - The scope where the table resides (implied to be within the code of the current receiver)
    /// @param table - The table name
    /// @param payer - The account that pays for the storage costs
    /// @param id - The primary key to which to associate the secondary key
    /// @param secondary - Pointer to the secondary key
    /// @return iterator to the newly created table row
    /// @post new secondary key association between primary key `id` and secondary key `*secondary` is created in the secondary quadruple-precision floating-point index table
    pub fn db_idx_long_double_store(
        scope: account_name,
        table: table_name,
        payer: account_name,
        id: u64,
        secondary: *const f64,
    ) -> i32;
}
extern "C" {
    /// Update an association for a quadruple-precision floating-point secondary key to a primary key in a secondary quadruple-precision floating-point index table
    ///
    /// @brief Update an association for a quadruple-precision floating-point secondary key to a primary key in a secondary quadruple-precision floating-point index table
    /// @param iterator - The iterator to the table row containing the secondary key association to update
    /// @param payer - The account that pays for the storage costs (use 0 to continue using current payer)
    /// @param secondary - Pointer to the **new** secondary key that will replace the existing one of the association
    /// @pre `iterator` points to an existing table row in the table
    /// @post the secondary key of the table row pointed to by `iterator` is replaced by `*secondary`
    pub fn db_idx_long_double_update(iterator: i32, payer: account_name, secondary: *const f64);
}
extern "C" {
    /// Remove a table row from a secondary quadruple-precision floating-point index table
    ///
    /// @brief Remove a table row from a secondary quadruple-precision floating-point index table
    /// @param iterator - Iterator to the table row to remove
    /// @pre `iterator` points to an existing table row in the table
    /// @post the table row pointed to by `iterator` is removed and the associated storage costs are refunded to the payer
    pub fn db_idx_long_double_remove(iterator: i32);
}
extern "C" {
    /// Find the table row following the referenced table row in a secondary quadruple-precision floating-point index table
    ///
    /// @brief Find the table row following the referenced table row in a secondary quadruple-precision floating-point index table
    /// @param iterator - The iterator to the referenced table row
    /// @param primary - Pointer to a `uint64_t` variable which will have its value set to the primary key of the next table row
    /// @return iterator to the table row following the referenced table row (or the end iterator of the table if the referenced table row is the last one in the table)
    /// @pre `iterator` points to an existing table row in the table
    /// @post `*primary` will be replaced with the primary key of the table row following the referenced table row if it exists, otherwise `*primary` will be left untouched
    pub fn db_idx_long_double_next(iterator: i32, primary: *mut u64) -> i32;
}
extern "C" {
    /// Find the table row preceding the referenced table row in a secondary quadruple-precision floating-point index table
    ///
    /// @brief Find the table row preceding the referenced table row in a secondary quadruple-precision floating-point index table
    /// @param iterator - The iterator to the referenced table row
    /// @param primary - Pointer to a `uint64_t` variable which will have its value set to the primary key of the previous table row
    /// @return iterator to the table row preceding the referenced table row assuming one exists (it will return -1 if the referenced table row is the first one in the table)
    /// @pre `iterator` points to an existing table row in the table or it is the end iterator of the table
    /// @post `*primary` will be replaced with the primary key of the table row preceding the referenced table row if it exists, otherwise `*primary` will be left untouched
    pub fn db_idx_long_double_previous(iterator: i32, primary: *mut u64) -> i32;
}
extern "C" {
    /// Find a table row in a secondary quadruple-precision floating-point index table by primary key
    ///
    /// @brief Find a table row in a secondary quadruple-precision floating-point index table by primary key
    /// @param code - The name of the owner of the table
    /// @param scope - The scope where the table resides
    /// @param table - The table name
    /// @param secondary - Pointer to a `long double` variable which will have its value set to the secondary key of the found table row
    /// @param primary - The primary key of the table row to look up
    /// @post If and only if the table row is found, `*secondary` will be replaced with the secondary key of the found table row
    /// @return iterator to the table row with a primary key equal to `id` or the end iterator of the table if the table row could not be found
    pub fn db_idx_long_double_find_primary(
        code: account_name,
        scope: account_name,
        table: table_name,
        secondary: *mut f64,
        primary: u64,
    ) -> i32;
}
extern "C" {
    /// Find a table row in a secondary quadruple-precision floating-point index table by secondary key
    ///
    /// @brief Find a table row in a secondary quadruple-precision floating-point index table by secondary key
    /// @param code - The name of the owner of the table
    /// @param scope - The scope where the table resides
    /// @param table - The table name
    /// @param secondary - Pointer to secondary key used to lookup the table row
    /// @param primary - Pointer to a `long double` variable which will have its value set to the primary key of the found table row
    /// @post If and only if the table row is found, `*primary` will be replaced with the primary key of the found table row
    /// @return iterator to the first table row with a secondary key equal to `*secondary` or the end iterator of the table if the table row could not be found
    pub fn db_idx_long_double_find_secondary(
        code: account_name,
        scope: account_name,
        table: table_name,
        secondary: *const f64,
        primary: *mut u64,
    ) -> i32;
}
extern "C" {
    /// Find the table row in a secondary quadruple-precision floating-point index table that matches the lowerbound condition for a given secondary key
    /// The table row that matches the lowerbound condition is the first table row in the table with the lowest secondary key that is >= the given key
    ///
    /// @brief Find the table row in a secondary quadruple-precision floating-point index table that matches the lowerbound condition for a given secondary key
    /// @param code - The name of the owner of the table
    /// @param scope - The scope where the table resides
    /// @param table - The table name
    /// @param secondary - Pointer to secondary key first used to determine the lowerbound and which is then replaced with the secondary key of the found table row
    /// @param primary - Pointer to a `uint64_t` variable which will have its value set to the primary key of the found table row
    /// @post If and only if the table row is found, `*secondary` will be replaced with the secondary key of the found table row
    /// @post If and only if the table row is found, `*primary` will be replaced with the primary key of the found table row
    /// @return iterator to the found table row or the end iterator of the table if the table row could not be found
    pub fn db_idx_long_double_lowerbound(
        code: account_name,
        scope: account_name,
        table: table_name,
        secondary: *mut f64,
        primary: *mut u64,
    ) -> i32;
}
extern "C" {
    /// Find the table row in a secondary quadruple-precision floating-point index table that matches the upperbound condition for a given secondary key
    /// The table row that matches the upperbound condition is the first table row in the table with the lowest secondary key that is > the given key
    ///
    /// @brief Find the table row in a secondary quadruple-precision floating-point index table that matches the upperbound condition for a given secondary key
    /// @param code - The name of the owner of the table
    /// @param scope - The scope where the table resides
    /// @param table - The table name
    /// @param secondary - Pointer to secondary key first used to determine the upperbound and which is then replaced with the secondary key of the found table row
    /// @param primary - Pointer to a `uint64_t` variable which will have its value set to the primary key of the found table row
    /// @post If and only if the table row is found, `*secondary` will be replaced with the secondary key of the found table row
    /// @post If and only if the table row is found, `*primary` will be replaced with the primary key of the found table row
    /// @return iterator to the found table row or the end iterator of the table if the table row could not be found
    pub fn db_idx_long_double_upperbound(
        code: account_name,
        scope: account_name,
        table: table_name,
        secondary: *mut f64,
        primary: *mut u64,
    ) -> i32;
}
extern "C" {
    /// Get an end iterator representing just-past-the-end of the last table row of a secondary quadruple-precision floating-point index table
    ///
    /// @brief Get an end iterator representing just-past-the-end of the last table row of a secondary quadruple-precision floating-point index table
    /// @param code - The name of the owner of the table
    /// @param scope - The scope where the table resides
    /// @param table - The table name
    /// @return end iterator of the table
    pub fn db_idx_long_double_end(
        code: account_name,
        scope: account_name,
        table: table_name,
    ) -> i32;
}
extern "C" {
    /// @brief Checks if a transaction is authorized by a provided set of keys and permissions
    ///
    /// @param trx_data - pointer to the start of the serialized transaction
    /// @param trx_size - size (in bytes) of the serialized transaction
    /// @param pubkeys_data - pointer to the start of the serialized vector of provided public keys
    /// @param pubkeys_size  - size (in bytes) of serialized vector of provided public keys (can be 0 if no public keys are to be provided)
    /// @param perms_data - pointer to the start of the serialized vector of provided permissions (empty permission name acts as wildcard)
    /// @param perms_size - size (in bytes) of the serialized vector of provided permissions
    ///
    /// @return 1 if the transaction is authorized, 0 otherwise
    pub fn check_transaction_authorization(
        trx_data: *const ::std::os::raw::c_char,
        trx_size: u32,
        pubkeys_data: *const ::std::os::raw::c_char,
        pubkeys_size: u32,
        perms_data: *const ::std::os::raw::c_char,
        perms_size: u32,
    ) -> i32;
}
extern "C" {
    /// @brief Checks if a permission is authorized by a provided delay and a provided set of keys and permissions
    ///
    /// @param account    - the account owner of the permission
    /// @param permission - the name of the permission to check for authorization
    /// @param pubkeys_data - pointer to the start of the serialized vector of provided public keys
    /// @param pubkeys_size  - size (in bytes) of serialized vector of provided public keys (can be 0 if no public keys are to be provided)
    /// @param perms_data - pointer to the start of the serialized vector of provided permissions (empty permission name acts as wildcard)
    /// @param perms_size - size (in bytes) of the serialized vector of provided permissions
    /// @param delay_us - the provided delay in microseconds (cannot exceed INT64_MAX)
    ///
    /// @return 1 if the permission is authorized, 0 otherwise
    pub fn check_permission_authorization(
        account: account_name,
        permission: permission_name,
        pubkeys_data: *const ::std::os::raw::c_char,
        pubkeys_size: u32,
        perms_data: *const ::std::os::raw::c_char,
        perms_size: u32,
        delay_us: u64,
    ) -> i32;
}
extern "C" {
    /// @brief Returns the last used time of a permission
    ///
    /// @param account    - the account owner of the permission
    /// @param permission - the name of the permission
    ///
    /// @return the last used time (in microseconds since Unix epoch) of the permission
    pub fn get_permission_last_used(account: account_name, permission: permission_name) -> i64;
}
extern "C" {
    /// @brief Returns the creation time of an account
    ///
    /// @param account    - the account
    ///
    /// @return the creation time (in microseconds since Unix epoch) of the account
    pub fn get_account_creation_time(account: account_name) -> i64;
}
extern "C" {
    /// Prints string
    /// @brief Prints string
    /// @param cstr - a null terminated string
    ///
    /// Example:
    ///
    /// @code
    /// prints("Hello World!"); // Output: Hello World!
    /// @endcode
    pub fn prints(cstr: *const ::std::os::raw::c_char);
}
extern "C" {
    /// Prints string up to given length
    /// @brief Prints string
    /// @param cstr - pointer to string
    /// @param len - len of string to be printed
    ///
    /// Example:
    ///
    /// @code
    /// prints_l("Hello World!", 5); // Output: Hello
    /// @endcode
    pub fn prints_l(cstr: *const ::std::os::raw::c_char, len: u32);
}
extern "C" {
    /// Prints value as a 64 bit signed integer
    /// @brief Prints value as a 64 bit signed integer
    /// @param value of 64 bit signed integer to be printed
    ///
    /// Example:
    ///
    /// @code
    /// printi(-1e+18); // Output: -1000000000000000000
    /// @endcode
    pub fn printi(value: i64);
}
extern "C" {
    /// Prints value as a 64 bit unsigned integer
    /// @brief Prints value as a 64 bit unsigned integer
    /// @param value of 64 bit unsigned integer to be printed
    ///
    /// Example:
    ///
    /// @code
    /// printui(1e+18); // Output: 1000000000000000000
    /// @endcode
    pub fn printui(value: u64);
}
extern "C" {
    /// Prints value as a 128 bit signed integer
    /// @brief Prints value as a 128 bit signed integer
    /// @param value is a pointer to the 128 bit signed integer to be printed
    ///
    /// Example:
    ///
    /// @code
    /// int128_t large_int(-87654323456);
    /// printi128(&large_int); // Output: -87654323456
    /// @endcode
    pub fn printi128(value: *const int128_t);
}
extern "C" {
    /// Prints value as a 128 bit unsigned integer
    /// @brief Prints value as a 128 bit unsigned integer
    /// @param value is a pointer to the 128 bit unsigned integer to be printed
    ///
    /// Example:
    ///
    /// @code
    /// uint128_t large_int(87654323456);
    /// printui128(&large_int); // Output: 87654323456
    /// @endcode
    pub fn printui128(value: *const uint128_t);
}
extern "C" {
    /// Prints value as single-precision floating point number
    /// @brief Prints value as single-precision floating point number (i.e. float)
    /// @param value of float to be printed
    ///
    /// Example:
    ///
    /// @code
    /// float value = 5.0 / 10.0;
    /// printsf(value); // Output: 0.5
    /// @endcode
    pub fn printsf(value: f32);
}
extern "C" {
    /// Prints value as double-precision floating point number
    /// @brief Prints value as double-precision floating point number (i.e. double)
    /// @param value of double to be printed
    ///
    /// Example:
    ///
    /// @code
    /// double value = 5.0 / 10.0;
    /// printdf(value); // Output: 0.5
    /// @endcode
    pub fn printdf(value: f64);
}
extern "C" {
    /// Prints value as quadruple-precision floating point number
    /// @brief Prints value as quadruple-precision floating point number (i.e. long double)
    /// @param value is a pointer to the long double to be printed
    ///
    /// Example:
    ///
    /// @code
    /// long double value = 5.0 / 10.0;
    /// printqf(value); // Output: 0.5
    /// @endcode
    pub fn printqf(value: *const f64);
}
extern "C" {
    /// Prints a 64 bit names as base32 encoded string
    /// @brief Prints a 64 bit names as base32 encoded string
    /// @param name - 64 bit name to be printed
    ///
    /// Example:
    /// @code
    /// printn(N(abcde)); // Output: abcde
    /// @endcode
    pub fn printn(name: u64);
}
extern "C" {

    pub fn printhex(data: *const ::std::os::raw::c_void, datalen: u32);
}
extern "C" {
    /// @brief Get the resource limits of an account
    /// Get the resource limits of an account
    /// @param account - name of the account whose resource limit to get
    /// @param ram_bytes - pointer to `int64_t` to hold retrieved ram limit in absolute bytes
    /// @param net_weight - pointer to `int64_t` to hold net limit
    /// @param cpu_weight - pointer to `int64_t` to hold cpu limit
    pub fn get_resource_limits(
        account: account_name,
        ram_bytes: *mut i64,
        net_weight: *mut i64,
        cpu_weight: *mut i64,
    );
}
extern "C" {
    /// @brief Set the resource limits of an account
    /// Set the resource limits of an account
    /// @param account - name of the account whose resource limit to be set
    /// @param ram_bytes - ram limit in absolute bytes
    /// @param net_weight - fractionally proportionate net limit of available resources based on (weight / total_weight_of_all_accounts)
    /// @param cpu_weight - fractionally proportionate cpu limit of available resources based on (weight / total_weight_of_all_accounts)
    pub fn set_resource_limits(
        account: account_name,
        ram_bytes: i64,
        net_weight: i64,
        cpu_weight: i64,
    );
}
extern "C" {
    /// Proposes a schedule change, once the block that contains the proposal becomes irreversible, the schedule is promoted to "pending" automatically. Once the block that promotes the schedule is irreversible, the schedule will become "active"
    /// @param producer_data - packed data of produce_keys in the appropriate producer schedule order
    /// @param producer_data_size - size of the data buffer
    ///
    /// @return -1 if proposing a new producer schedule was unsuccessful, otherwise returns the version of the new proposed schedule
    pub fn set_proposed_producers(
        producer_data: *mut ::std::os::raw::c_char,
        producer_data_size: u32,
    ) -> i64;
}
extern "C" {
    /// @brief Set new active producers
    /// Set new active producers. Producers will only be activated once the block which starts the next round is irrreversible
    /// @param producer_data - pointer to producer schedule packed as bytes
    /// @param producer_data_size - size of the packed producer schedule
    /// @pre `producer_data` is a valid pointer to a range of memory at least `producer_data_size` bytes long that contains serialized produced schedule data
    pub fn set_active_producers(
        producer_data: *mut ::std::os::raw::c_char,
        producer_data_size: u32,
    );
}
extern "C" {
    /// @brief Check if an account is privileged
    /// Check if an account is privileged
    /// @param account - name of the account to be checked
    /// @return true if the account is privileged
    /// @return false if the account is not privileged
    pub fn is_privileged(account: account_name) -> bool;
}
extern "C" {
    /// @brief Set the privileged status of an account
    /// Set the privileged status of an account
    /// @param account - name of the account whose privileged account to be set
    /// @param is_priv - privileged status
    pub fn set_privileged(account: account_name, is_priv: bool);
}
extern "C" {
    /// @brief Set the blockchain parameters
    /// Set the blockchain parameters
    /// @param data - pointer to blockchain parameters packed as bytes
    /// @param datalen - size of the packed blockchain parameters
    /// @pre `data` is a valid pointer to a range of memory at least `datalen` bytes long that contains packed blockchain params data
    pub fn set_blockchain_parameters_packed(data: *mut ::std::os::raw::c_char, datalen: u32);
}
extern "C" {
    /// @brief Retrieve the blolckchain parameters
    /// Retrieve the blolckchain parameters
    /// @param data - output buffer of the blockchain parameters, only retrieved if sufficent size to hold packed data.
    /// @param datalen - size of the data buffer, 0 to report required size.
    /// @return size of the blockchain parameters
    /// @pre `data` is a valid pointer to a range of memory at least `datalen` bytes long
    /// @post `data` is filled with packed blockchain parameters
    pub fn get_blockchain_parameters_packed(data: *mut ::std::os::raw::c_char, datalen: u32)
        -> u32;
}
extern "C" {
    /// @brief Activate new feature
    /// Activate new feature
    /// @param f - name (identifier) of the feature to be activated
    pub fn activate_feature(f: i64);
}
extern "C" {
    /// Sends a deferred transaction.
    ///
    /// @brief Sends a deferred transaction.
    /// @param sender_id - ID of sender
    /// @param payer - Account paying for RAM
    /// @param serialized_transaction - Pointer of serialized transaction to be deferred
    /// @param size - Size to reserve
    /// @param replace_existing - f this is `0` then if the provided sender_id is already in use by an in-flight transaction from this contract, which will be a failing assert. If `1` then transaction will atomically cancel/replace the inflight transaction
    pub fn send_deferred(
        sender_id: *const uint128_t,
        payer: account_name,
        serialized_transaction: *const ::std::os::raw::c_char,
        size: usize,
        replace_existing: u32,
    );
}
extern "C" {
    /// Cancels a deferred transaction.
    ///
    /// @brief Cancels a deferred transaction.
    /// @param sender_id - The id of the sender
    ///
    /// @pre The deferred transaction ID exists.
    /// @pre The deferred transaction ID has not yet been published.
    /// @post Deferred transaction canceled.
    ///
    /// @return 1 if transaction was canceled, 0 if transaction was not found
    ///
    /// Example:
    ///
    /// @code
    /// id = 0xffffffffffffffff
    /// cancel_deferred( id );
    /// @endcode
    pub fn cancel_deferred(sender_id: *const uint128_t) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Access a copy of the currently executing transaction.
    ///
    /// @brief Access a copy of the currently executing transaction.
    /// @param buffer - a buffer to write the current transaction to
    /// @param size - the size of the buffer, 0 to return required size
    /// @return the size of the transaction written to the buffer, or number of bytes that can be copied if size==0 passed
    pub fn read_transaction(buffer: *mut ::std::os::raw::c_char, size: usize) -> usize;
}
extern "C" {
    /// Gets the size of the currently executing transaction.
    ///
    /// @brief Gets the size of the currently executing transaction.
    /// @return size of the currently executing transaction
    pub fn transaction_size() -> usize;
}
extern "C" {
    /// Gets the block number used for TAPOS on the currently executing transaction.
    ///
    /// @brief Gets the block number used for TAPOS on the currently executing transaction.
    /// @return block number used for TAPOS on the currently executing transaction
    /// Example:
    /// @code
    /// int tbn = tapos_block_num();
    /// @endcode
    pub fn tapos_block_num() -> ::std::os::raw::c_int;
}
extern "C" {
    /// Gets the block prefix used for TAPOS on the currently executing transaction.
    ///
    /// @brief Gets the block prefix used for TAPOS on the currently executing transaction.
    /// @return block prefix used for TAPOS on the currently executing transaction
    /// Example:
    /// @code
    /// int tbp = tapos_block_prefix();
    /// @endcode
    pub fn tapos_block_prefix() -> ::std::os::raw::c_int;
}
extern "C" {
    /// Gets the expiration of the currently executing transaction.
    ///
    /// @brief Gets the expiration of the currently executing transaction.
    /// @return expiration of the currently executing transaction
    /// Example:
    /// @code
    /// time tm = expiration();
    /// eosio_print(tm);
    /// @endcode
    pub fn expiration() -> time;
}
extern "C" {
    /// Retrieves the indicated action from the active transaction.
    ///
    /// @brief Retrieves the indicated action from the active transaction.
    /// @param type - 0 for context free action, 1 for action
    /// @param index - the index of the requested action
    /// @param buff - output packed buff of the action
    /// @param size - amount of buff read, pass 0 to have size returned
    /// @return the size of the action, -1 on failure
    pub fn get_action(
        type_: u32,
        index: u32,
        buff: *mut ::std::os::raw::c_char,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Retrieve the signed_transaction.context_free_data[index].
    ///
    /// @brief Retrieve the signed_transaction.context_free_data[index].
    /// @param index - the index of the context_free_data entry to retrieve
    /// @param buff - output buff of the context_free_data entry
    /// @param size - amount of context_free_data[index] to retrieve into buff, 0 to report required size
    /// @return size copied, or context_free_data[index].size() if 0 passed for size, or -1 if index not valid
    pub fn get_context_free_data(
        index: u32,
        buff: *mut ::std::os::raw::c_char,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
